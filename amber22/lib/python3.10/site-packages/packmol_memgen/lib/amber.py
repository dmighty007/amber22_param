#! /usr/bin/python

from __future__ import print_function
import sys, os 
import numpy as np
import logging
from .measure_parms import pdb_parse
module_path = os.path.abspath(os.path.dirname(__file__))+os.path.sep

logger = logging.getLogger("pmmg_log")

if os.name == 'nt':
    exe_suffix =    ".exe"
    script_suffix = ".bat"
else: 
    exe_suffix =    ""
    script_suffix = ""

try:
    amberhome = os.environ['AMBERHOME']
    amberhome_bin = os.path.join(amberhome, "bin")

    reduce    = os.path.join(amberhome_bin, "reduce" + exe_suffix)
    leap      = os.path.join(amberhome_bin, "tleap"  + script_suffix) 
    sander    = os.path.join(amberhome_bin, "sander" + exe_suffix)
    pmemd     = os.path.join(amberhome_bin, "pmemd"  + exe_suffix)
    ambpdb    = os.path.join(amberhome_bin, "ambpdb" + exe_suffix)
    cgconv    = os.path.join(amberhome, "dat/SIRAH/tools/CGCONV/cgconv.pl")
    if not os.path.exists(pmemd):
        logger.warning("PMEMD not found. Setting path to SANDER")
        pmemd = sander
    for exec_path in [reduce,leap,sander,ambpdb]:
        if not os.path.exists(exec_path):
            logger.warning("AMBER path found, but "+exec_path+" executable is not available")
except:
    logger.critical("AMBER environment variables not found!")

def reduce_protonate(pdb,overwrite=False, build=False):
    output = pdb[:-4]+"_H.pdb"
    if os.path.exists(output) and not overwrite:
        return output
    if build:
        os.system(reduce+" -Quiet -BUILD "+pdb+" > "+output+" 2>> reduce_warn.log")
    else:
        os.system(reduce+" -Quiet "+pdb+" > "+output+" 2>> reduce_warn.log")
    if os.stat(output).st_size == 0:
        return "error"
    return output

def reduce_trim(pdb,overwrite=False):
    output = pdb[:-4]+"_Trim.pdb"
    if os.path.exists(output) and not overwrite:
        return output
    os.system(reduce+" -Trim "+pdb+" > "+output+" 2>> reduce_Trim_warn.log")
    if os.stat(output).st_size == 0:
        return "error"
    return output

def sirah_cgconv(pdb,overwrite=False):
    output = pdb[:-4]+"_cg.pdb"
    if os.path.exists(output) and not overwrite:
        return output
    os.system(cgconv+" -i "+pdb+" -o "+output+" 2>> cgconv.log")
    if os.stat(output).st_size == 0:
        return "error"
    return output


def amber_minimize(infiles,restraintmask=None, sd_steps = 5000, cg_steps = 5000,output="protein",min_script="min.in",outfile="minimized.pdb", engine="pmemd"):
    total = sd_steps+cg_steps
    script = "Memgen AMBER minimization with restraints\n"
    script += " &cntrl\n"
    script += "  nmropt = 0,\n"
    script += "  imin = 1,\n"
    if restraintmask is not None:
        script += "  ntr = 1,\n"
        script += "  restraint_wt = 10,\n"
        script += "  restraintmask = '"+restraintmask+"',\n" #(:PROT | @P31)
    script += "  maxcyc = "+str(total)+",\n"
    script += "  ncyc = "+str(sd_steps)+",\n"
    script += " &end\n"
    handle = open(min_script,"w")
    handle.write(script)
    handle.close()
    if engine == "pmemd":
        os.system(pmemd+" -O -i {} -o {} -p {} -c {} -r {} -ref {}".format(min_script,min_script.replace(".in",".out"),infiles[1],infiles[2],min_script.replace(".in",".restrt"),infiles[2]))
    elif engine == "sander":
        os.system(sander+" -O -i {} -o {} -p {} -c {} -r {} -ref {}".format(min_script,min_script.replace(".in",".out"),infiles[1],infiles[2],min_script.replace(".in",".restrt"),infiles[2]))
    else:
        logger.warning("MM engine not found!")
    os.system(ambpdb+" -p "+infiles[1]+" -c "+min_script.replace(".in",".restrt")+" > "+outfile)
    return (outfile,infiles[1],min_script.replace(".in",".restrt"))
    

def prepare_leap(pdb,
                dim_vec=None,
                leap_script="leap.in",
                ligands=None,
                cation="K+",
                anion="Cl-",
                suffix="_par", 
                custom_lines=None,
                gaff2=False,
                sirah=False,
                extended=False,
                x_solvent=False, 
                cli=False, 
                nocounter=False, 
                ffprot="ff14SB", 
                ffwat="tip3p",
                fflip="lipid21"
                ):

    if sirah:
        script = "addPath %s/dat/SIRAH/\n" % (amberhome) 
        script += "source leaprc.sirah\n"
    else:
        if fflip == "lipid21":
            script =  "source leaprc.%s\n" % (fflip)
        else:
            script =  "source oldff/leaprc.%s\n" % (fflip)
        if extended or x_solvent:
            script += "addPath %s../data/\n" % (module_path)
        if extended:
            script += "source leaprc.lipid_ext\n"
        script += "source leaprc.protein.%s\n" % (ffprot)
        script += "source leaprc.water.%s\n" % (ffwat)
        if x_solvent:
            script += "source leaprc.extra_solvents\n"

    if custom_lines is not None:
        for line in [line for line in custom_lines if (line.startswith("load") or line.startswith("source"))]:
            script += line+"\n"
    if ligands is not None:
        if gaff2:
            script += "source leaprc.gaff2\n"
        else:
            script += "source leaprc.gaff\n"
        for ligand in ligands:
            params = ligand.split(":")      # AMBER frcmod,lib
            script += "loadamberparams "+params[0]+"\n"
            script += "loadoff "+params[1]+"\n"
    if cli:
        try:
            logger.debug("Running pdb4amber to clean the output")
            import pdb4amber
            p4alogger = logging.getLogger('pdb4amber_log')
            logging.StreamHandler().setLevel(logging.WARNING)
            pdb4amber.main(["-i",pdb,"-o","cli_clean.pdb","-l","p4a.log"])
            logging.StreamHandler().setLevel(logging.INFO)
        except:
            logger.critical("CRITICAL:\n  pdb4amber failed! Is it available in your PYTHONPATH?")
            exit()
        script += "SYS = loadpdb cli_clean.pdb \n"
        cli_leap = script
        cli_leap += "savepdb SYS cli_temp.pdb"
        handle = open("leap_cli.in","w")
        handle.write(cli_leap)
        handle.close()
        os.system(leap+" -f leap_cli.in > leap_cli.log 2>&1")
        cli_temp = pdb_parse("cli_temp.pdb", onlybb=False)
        for res in cli_temp:
            if res[0] == "CLI":
                script += "bond SYS.%d.C11B SYS.%d.C12\n" % (res[1],res[1]+2)
                script += "bond SYS.%d.C21B SYS.%d.C12\n" % (res[1],res[1]+3)
                script += "deletebond SYS.%d.C12 SYS.%d.C12\n" % (res[1]+2,res[1]+3)
    else:
        script += "SYS = loadpdb "+pdb+" \n"
    if custom_lines is not None:
        for line in [line for line in custom_lines if not (line.startswith("load") or line.startswith("source"))]:
            script += line+"\n"
    if dim_vec is None:
        script += "setBox SYS vdw\n"
    else:
        script += "set SYS box {{ {:6.3f} {:6.3f} {:6.3f} }}\n".format(dim_vec[0],dim_vec[1],dim_vec[2])
    if cation == "Ca2+":
        cation = "CA"
    if not nocounter:
        script += "addionsrand SYS "+cation+" 0\n"
        script += "addionsrand SYS "+anion+" 0\n"
    script += "savepdb SYS "+pdb.replace(".pdb",suffix+".pdb")+"\n"
    script += "saveAmberParm SYS "+pdb.replace(".pdb",suffix+".top")+" "+pdb.replace(".pdb",suffix+".crd")+"\n"
    script += "quit\n"
    handle = open(leap_script,"w")
    handle.write(script)
    handle.close()
    os.system(leap+" -f "+leap_script+" > leap_.log 2>&1")
    if not os.path.exists(pdb.replace(".pdb",suffix+".top")):
        logger.critical("Leap Failed! Check the leap_.log file")
    return (pdb.replace(".pdb",suffix+".pdb"),pdb.replace(".pdb",suffix+".top"),pdb.replace(".pdb",suffix+".crd"))
    

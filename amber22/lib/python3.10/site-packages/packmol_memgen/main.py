#!/usr/bin/env python

from __future__ import print_function
import os, sys, math, subprocess, random, argparse, shutil, atexit, signal, logging
import tarfile
script_path = os.path.abspath(os.path.dirname(__file__))+os.path.sep
sys.path.append(script_path)
from argparse import RawDescriptionHelpFormatter
from lib.measure_parms import *
from lib.amber import *
from lib import tqdm
from lib.pdbremix.lib.docopt import docopt
from lib.pdbremix import pdbatoms
from lib.pdbremix.rmsd import *
from lib.pdbremix.volume import volume
from lib.charmmlipid2amber.charmmlipid2amber import charmmlipid2amber

head = """

 _____           _                    _
|  __ \         | |                  | |
| |__) |_ _  ___| | ___ __ ___   ___ | |
|  ___/ _` |/ __| |/ / '_ ` _ \ / _ \| |
| |  | (_| | (__|   <| | | | | | (_) | |
|_|   \__,_|\___|_|\_\_| |_| |_|\___/|_|
                                         ___
                  /\/\   ___ _ __ ___   / _ \___ _ __
                 /    \ / _ \ '_ ` _ \ / /_\/ _ \ '_ \ 
                / /\/\ \  __/ | | | | / /_ \  __/ | | |
                \/    \/\___|_| |_| |_\____/\___|_| |_|


###############################################################
Stephan Schott-Verdugo 2016-11-07 UPDATED: 2022-03-08   v1.2.3
Generated at CPCLab at Heinrich Heine University Duesseldorf
      &      CBCLab at Forschungszentrum Juelich
###############################################################\n"""
#CHECK CHANGELOG IN README.rst

try:
    os.environ['COLUMNS'] = str(shutil.get_terminal_size()[0])
except:
    try:
        from backports.shutil_get_terminal_size import get_terminal_size
        os.environ['COLUMNS'] = str(get_terminal_size()[0])
    except:
        os.environ['COLUMNS'] = "80"


explanation = """The script creates an input file for PACKMOL for creating a bilayer system with a protein inserted in it. The input pdb file will be protonated and oriented by default by using reduce and MEMEMBED; the user is encouraged to check the input and output files carefully!  If the protein is preoriented, for example by using PPM webserver from OPM (http://opm.phar.umich.edu/server.php), be sure to set the corresponding flag (--preoriented).  In some cases the packed system might crash during the first MD step, specially when the system is minimized by using pmemd GPU code (cudaFree Memory allocation error). It's highly recommended that the minimization steps are performed on cpus (--minimize), but also changes in the box boundaries or repacking with --random as an argument might help.

 If you use this script, please cite:

    **Schott-Verdugo, S and Gohlke, H, PACKMOL-Memgen: A Simple-To-Use, Generalized Workflow for Membrane-Protein-Lipid-Bilayer System Building, Journal of Chemical Information and Modeling,  59, 6, 2522-2528., 2019

    you should also cite and/or acknowledge:

    **Leandro Martinez (L. Martinez, R. Andrade, E. G. Birgin, J. M. Martinez. Packmol: A package for building initial configurations for molecular dynamics simulations. Journal of Computational Chemistry, 30(13):2157-2164, 2009.)
    **Tim Nugent (Nugent T, Jones DT. Membrane protein orientation and refinement using a knowledge-based statistical potential. BMC Bioinformatics. 2013 Sep 18;14:276.)
    **Bosco K. Ho (http://boscoh.com/ ; https://github.com/boscoh/pdbremix)
    **Benjamin D. Madej (charmmlipid2amber.py)

"""

explanation = explanation+"-"*int(os.environ['COLUMNS'])

short_help = "-h" in sys.argv

parser = argparse.ArgumentParser(prog="packmol-memgen", description = explanation, add_help=False, formatter_class=RawDescriptionHelpFormatter)
parser.add_argument("-h",     action="help", help="prints this help message and exits" if short_help else "prints a short help message and exits")
parser.add_argument("--help", action="help", help="prints an extended help message and exits" if short_help else "prints this help message and exits")
parser.add_argument("--available_lipids",action="store_true",     help="list of available lipids and corresponding charges")
parser.add_argument("--available_lipids_all",action="store_true", help="list all lipids including experimental. Huge output (>4000 lines)! Think about grepping the lipid you want (packmol-memgen --available_lipids_all | grep YOUR_LIPID_PATTERN)")
parser.add_argument("--available_solvents",action="store_true",     help="list of available solvents and corresponding charges")
parser.add_argument("-l","--lipids",action="append",metavar="LIP1:LIP2//LIP3",help="Lipid(s) to be used for embeding the protein. It should be a single string separated by ':' . If different composition is used in leaflets, add '//' as a separator.[ex. CHL1:DOPC//DOPE for a lower leaflet with CHL1+DOPC and an upper leaflet with DOPE]. Can be defined multiple times for multi-bilayer systems (stacks 'up' or 'outside')")
parser.add_argument("-r","--ratio",action="append",metavar="R1:R2//R3", help="mixture ratio (set to 1 if only one lipid required). Must be in the same order and syntax as in lipids, and defined once per bilayer [ex. 1:2//1] ")
parser.add_argument("--solvents",type=str,    metavar="SOL1:SOL2",help="Solvent(s) to be used for the packing. As lipids, it should be a single string separated by ':'. Water by default.")
parser.add_argument("--solvent_ratio",type=str,metavar="SR1:SR2", help="mixture ratio (set to 1 if only one solvent required). Must be in the same order and syntax as in solvents")
parser.add_argument("--dist",         type=float, default=15.0,   help=argparse.SUPPRESS if short_help else "specify the minimum distance between the maxmin values for x y and z to the box boundaries. Default = 15 A. Worst case scenario is considered, so real distance could be larger")
parser.add_argument("--dist_wat", type=float, default=17.5,       help=argparse.SUPPRESS if short_help else "specify the width of the water layer over the membrane or protein in the z axis. Default = 17.5")
parser.add_argument("--distxy_fix",   type=float,                 help="specify the membrane patch side length in the x and y axis. Useful when only lipids are packed! By default is calculated flexibly depending on the protein")
parser.add_argument("--noxy_cen",     action="store_false",       help=argparse.SUPPRESS if short_help else "disable default centering in the xy plane that ensures symmetric membrane building. Not recommended!")
parser.add_argument("--channel_plug",  type=float,                help=argparse.SUPPRESS if short_help else "establishes a cylindrical restraint on the lipids using the protein z height and the input value as xy radius. A value of 0 will use half of the protein radius. By default, no restraint is imposed.")
parser.add_argument("--self_assembly",      action="store_true",  help=argparse.SUPPRESS if short_help else "places lipids all over the packed box, and not in a bilayer.")
parser.add_argument("--xygauss",nargs=3,metavar=("C","D","H"),    help=argparse.SUPPRESS if short_help else "set parameters for a curved 2d gaussian in the xy plane. Parameters are uncertainty in x, uncertainty in y and gaussian height. By default, membranes are flat.")
parser.add_argument("--curvature",    type=float, default=None,   help=argparse.SUPPRESS if short_help else "set the curvature of the membrane patch. By default, membranes are flat.")
parser.add_argument("--curv_radius",  type=float, default=None,   help=argparse.SUPPRESS if short_help else "inverse of curvature. Set the curvature as if on a vesicle with the provided radius.")
parser.add_argument("--dims", nargs=3,metavar=("X","Y","Z"),      type=float,default=[0,0,0], help=argparse.SUPPRESS if short_help else "box dimensions vector for the  x y z  axes. Be sure to use dimensions that cover the complete protein to be packed!!")
parser.add_argument("--solvate",      action="store_true",        help=argparse.SUPPRESS if short_help else "solvate the system without adding lipids. Disables the flag --dist_wat, using only --dist to set the box size. Under development!")
parser.add_argument("--cubic",        action="store_true",        help=argparse.SUPPRESS if short_help else "cube shaped box. Only works with --solvate")
parser.add_argument("--vol",          action="store_true",        help=argparse.SUPPRESS if short_help else "do the lipid number estimation based on the volume occupied by the leaflet instead of APL. This might cause a great overestimation of the number of lipid molecules!")
parser.add_argument("--leaflet",      type=float, default=23.0,   help=argparse.SUPPRESS if short_help else "set desired leaflet width. 23 by default.")
parser.add_argument("--lip_offset",   type=float, default=1.0,    help=argparse.SUPPRESS if short_help else "factor that multiplies the x/y sizes for the lipid membrane segment. Might improve packing and handling by AMBER")
parser.add_argument("--apl_offset",   action="append",            help=argparse.SUPPRESS if short_help else "factor that multiplies the default APL values. Helpful if packing stretched membranes.")
parser.add_argument("--tailplane",    type=float,                 help=argparse.SUPPRESS if short_help else "sets the position BELOW which the CH3 carbon atoms in the tail should be. By default defined in parameter file")
parser.add_argument("--headplane",    type=float,                 help=argparse.SUPPRESS if short_help else "sets the position ABOVE which the PO4 phosphorus and N atoms in the polar head group should be.By default defined in parameter file")
parser.add_argument("--plot",         action="store_true",        help=argparse.SUPPRESS if short_help else "makes a simple plot of loop number vs GENCAN optimization function value, and outputs the values to GENCAN.dat")
parser.add_argument("--traj",         action="store_true",        help=argparse.SUPPRESS if short_help else "saves all intermediate steps into separate pdb files")
parser.add_argument("--notgridvol",   action="store_false",       help=argparse.SUPPRESS if short_help else "skips grid building for volume estimation, and the calculation is done just by estimating density")
parser.add_argument("--notprotonate", action="store_false",       help=argparse.SUPPRESS if short_help else "skips protonation by reduce")
parser.add_argument("--reducebuild",  action="store_true",        help=argparse.SUPPRESS if short_help else "build step by reduce (protonation of His and side-chain flips). Use with care if parametrizing with the script!")
parser.add_argument("--keep",         action="store_false",       help=argparse.SUPPRESS if short_help else "skips deleting temporary files")
parser.add_argument("--noprogress",   action="store_true",        help=argparse.SUPPRESS if short_help else "avoids the printing of progress bar with time estimation in the final stage. Recommended if the job is piped into a file")
parser.add_argument("--apl_exp",      action="store_true",        help=argparse.SUPPRESS if short_help else "use experimental APL where available, like AmberTools18 release. Kept for consistency with older versions. By default, terms estimated with Lipid17 are used")
parser.add_argument("--memgen_parm", type=str,                    help=argparse.SUPPRESS if short_help else "load custom memgen.parm file with APL and VOL values. Extends and overwrites default values")
parser.add_argument("--solvent_parm", type=str,                   help=argparse.SUPPRESS if short_help else "load custom solvent.parm file with densities and molecular weights. Extends and overwrites default values")
parser.add_argument("--overwrite",    action="store_true",        help=argparse.SUPPRESS if short_help else "overwrite, even if files are present")
parser.add_argument("--nottrim",      action="store_false",       help=argparse.SUPPRESS if short_help else "doesn't trim preexisting hydrogens in the structure")
parser.add_argument("--log",type=str,default="packmol-memgen.log",help=argparse.SUPPRESS if short_help else "log file name where detailed information is to be written")
parser.add_argument("-o","--output",type=str,                     help=argparse.SUPPRESS if short_help else "name of the PACKMOL generated PDB file")
parser.add_argument("--charmm",     action="store_true",          help=argparse.SUPPRESS if short_help else "the output will be in CHARMM format instead of AMBER. Works only for small subset of lipids (see --available_lipids)")
parser.add_argument("--translate", nargs=3, type=float, default=[0,0,0], help=argparse.SUPPRESS if short_help else "pass a vector as  x y z  to translate the oriented pdb. Ex. ' 0 0 4 '")
parser.add_argument("--sirah", action="store_true",               help=argparse.SUPPRESS if short_help else "use SIRAH lipids, and corase-grain protein input. Will adapt tolerance accordingly. Only small subset of lipids available!")
parser.add_argument("--verbose",    action="store_true",          help=argparse.SUPPRESS if short_help else "verbose mode")

inputs = parser.add_argument_group('Inputs')
inputs.add_argument("-p","--pdb",           action="append",       help="PDB or PQR file(s) to embed. If many bilayers, it has to be specified once for each bilayer. 'None' can be specified and a bilayer without protein will be generated [ex. --pdb PDB1.pdb --pdb None --pdb PDB2.pdb (3 bilayers without protein in the middle)]. If no PDB is provided, the bilayer(s) will be membrane only (--distxy_fix has to be defined).")
inputs.add_argument("--solute",        action="append",            help=argparse.SUPPRESS if short_help else "adds pdb as solute into the water. Concentration has to be specified")
inputs.add_argument("--solute_con",    action="append",            help=argparse.SUPPRESS if short_help else "number of molecules/concentration to be used. Concentrations are specified in Molar by adding an 'M' as a suffix (Ex. 0.15M). If not added, a number of molecules is assumed.")
inputs.add_argument("--solute_charge", action="append",            help=argparse.SUPPRESS if short_help else "absolute charge of the included solute (Ex. -2). To be considered in the system neutralization")
inputs.add_argument("--solute_inmem",  action="store_true",        help=argparse.SUPPRESS if short_help else "solute should be added to membrane fraction")
inputs.add_argument("--solute_prot_dist",  type=float,             help=argparse.SUPPRESS if short_help else "establishes a cylindrical restraint using the protein xy radius and z height + the input value. A value of 0 will use the protein radius. By default, no restraint is imposed.")

embedopt = parser.add_argument_group('MEMEMBED options')
embedopt.add_argument("--preoriented",  action="store_true",          help="use this flag if the protein has been previosuly oriented and you want to avoid running MEMEMBED (i.e. from OPM)")
embedopt.add_argument("--double_span",  action="store_true",          help=argparse.SUPPRESS) #"orient protein twice, assuming it spans two membrane bilayer")
embedopt.add_argument("--n_ter",        action="append",              help=argparse.SUPPRESS if short_help else "'in' or 'out'. By default proteins are oriented with the n_ter oriented 'in' (or 'down'). relevant for multi layer system. If defined for one protein, it has to be defined for all of them, following previous order")
embedopt.add_argument("--barrel",       action="store_true",          help=argparse.SUPPRESS if short_help else "use MEMEMBED in beta barrel mode")
embedopt.add_argument("--keepligs",     action="store_true",          help=argparse.SUPPRESS if short_help else "MEMEMBED by default cleans the PDB. Use this flag to keep the ligands on the original PDB")
embedopt.add_argument("--mem_opt",type=str,default="3",choices=["0","1","2","3"],help=argparse.SUPPRESS if short_help else "MEMEMBED optimization algorithm. 0 = Genetic algorithm, 1 = Grid, 2 = Direct, 3 = GA five times")
embedopt.add_argument("--memembed",type=str,                         help=argparse.SUPPRESS)

packmolopt = parser.add_argument_group('PACKMOL options')
packmolopt.add_argument("--nloop",       type=int,default=20,         help=argparse.SUPPRESS if short_help else "number of nloops for GENCAN routine in PACKMOL. PACKMOL MEMGEN uses 20 by default; you might consider increasing the number to improve packing. Increasing the number of components requires more GENCAN loops.")
packmolopt.add_argument("--nloop_all",   type=int,default=100,        help=argparse.SUPPRESS if short_help else "number of nloops for all-together packing. PACKMOL MEMGEN uses 100 by default.")
packmolopt.add_argument("--tolerance",   type=float,default=2.0,      help=argparse.SUPPRESS if short_help else "tolerance for detecting clashes between molecules in PACKMOL (defined as radius1+radius2). PACKMOL uses 2.0 by default.")
packmolopt.add_argument("--prot_rad",   type=float,default=1.5,       help=argparse.SUPPRESS if short_help else "radius considered for protein atoms to establish the tolerance for detecting clashes. PACKMOL MEMGEN uses 1.5 by default.")
packmolopt.add_argument("--writeout",                                 help=argparse.SUPPRESS if short_help else "frequency for writing intermediate results. PACKMOL uses 10 by default.")
packmolopt.add_argument("--notrun",       action="store_false",       help=argparse.SUPPRESS if short_help else "will not run PACKMOL, even if it's available")
packmolopt.add_argument("--random",       action="store_true",        help=argparse.SUPPRESS if short_help else "turns PACKMOL random seed generator on. If a previous packing failed in the minimization problem, repacking with this feature on might solve the problem.")
packmolopt.add_argument("--packall",  action="store_true",            help=argparse.SUPPRESS if short_help else "skips initial individual packing steps")
packmolopt.add_argument("--movebadrandom", action="store_true",       help=argparse.SUPPRESS if short_help else "randomizes positions of badly placed molecules in initial guess")
packmolopt.add_argument("--packlog",type=str,default="packmol",       help=argparse.SUPPRESS if short_help else "prefix for generated PACKMOL input and log files")
packmolopt.add_argument("--packmol",type=str,                         help=argparse.SUPPRESS)

saltopt = parser.add_argument_group('Salts and charges')
saltopt.add_argument("--salt",        action="store_true",         help=argparse.SUPPRESS if short_help else "adds salt at a concentration of 0.15M by default. Salt is always added considering estimated charges for the system.")
saltopt.add_argument("--salt_c",default="K+",choices=["K+","Na+","Ca2+","Mg2+"], help=argparse.SUPPRESS if short_help else "cation to add. (K+ by default)")
saltopt.add_argument("--saltcon", type=float, default=0.15,        help=argparse.SUPPRESS if short_help else "modifies the default concentration for KCl. [M]")
saltopt.add_argument("--salt_override",action="store_true",        help=argparse.SUPPRESS if short_help else "if the concentration of salt specified is less than the required to neutralize, will try to continue omitting the warning")
saltopt.add_argument("--nocounter",action="store_true",            help=argparse.SUPPRESS if short_help else "no counterions are added. Will depend on pmemd 'plasma' neutralization")

amberopt = parser.add_argument_group('AMBER options')
amberopt.add_argument("--minimize",     action="store_true",        help="performs minimization by using pmemd.")
amberopt.add_argument("--ligand_param",default=None,action="append",help=argparse.SUPPRESS if short_help else "in case of parametrizing or minimizing the system with non-canonical molecules. Give frcmod and lib filenames separated by ':' [ex. --ligand_param FRCMOD:LIB].")
amberopt.add_argument("--gaff2",     action="store_true",           help=argparse.SUPPRESS if short_help else "if ligand parameters are included, use GAFF2 during parametrization (GAFF is used by default)")
amberopt.add_argument("--leapline",default=None,action="append",    help=argparse.SUPPRESS if short_help else "extra lines added to the leap parametrization process. Delimit the line with quotes. The system is called SYS into leap [ex. --leapline 'bond SYS.4.SG SYS.122.SG' to form SS bond between SG atoms of residues 4 and 122]")
amberopt.add_argument("--sander",        action="store_true",       help=argparse.SUPPRESS if short_help else "use sander instead of pmemd.")
amberopt.add_argument("--parametrize",   action="store_true",       help="parametrizes the system by using tleap. Uses LIPID17, ff14SB and TIP3P by default (check --ffwat and --ffprot)")
amberopt.add_argument("--ffwat",default=None,choices=["tip3p","tip4pd","tip4pew","opc", "spce", "spceb", "fb3"], help=argparse.SUPPRESS if short_help else "water model to be used during parametrization.If not set explicitly, will change depending on the protein ff (--ffprot)")
amberopt.add_argument("--ffprot",default="ff14SB",choices=["ff14SB","ff15ipq","ff19SB"], help=argparse.SUPPRESS if short_help else "protein ff to be used during parametrization.")
amberopt.add_argument("--fflip",default="lipid21",choices=["lipid21","lipid17"], help=argparse.SUPPRESS if short_help else "lipid ff to be used during parametrization.If Lipid21 is available, will be selected by default.")
amberopt.add_argument("--tight_box",     action="store_true",       help=argparse.SUPPRESS if short_help else "sets box dimension according to restraints used during the packing. The default uses a vdW distance to the boundary")

compel = parser.add_argument_group('Computational electophysiology')
compel.add_argument("--double",       action="store_true",        help=argparse.SUPPRESS if short_help else "asumes a stacked double bilayer system for CompEL. The composition in --lipids will be used for both bilayers flipping the leaflets")
compel.add_argument("--charge_imbalance", type=int, default=0,    help=argparse.SUPPRESS if short_help else "sets a charge imbalance between compartments (in electron charge units). A positive imbalance implies an increase (decrease) in cations (anions) in the central compartment.")
compel.add_argument("--imbalance_ion", type=str, default="cat", choices=["cat","an"], help=argparse.SUPPRESS if short_help else "sets if cations or anions are used to imbalance the system charges. ('cat' by default)")

logger = logging.getLogger("pmmg_log")

def main(args):
    loghandle = logging.FileHandler(args.log,mode="a")
    loghandle.setFormatter(logging.Formatter('%(asctime)s:%(levelname)s:\n%(message)s',datefmt='%m/%d/%Y %I:%M:%S %p'))
    logger.addHandler(loghandle)
    streamer = logger.handlers[0]
    streamer.setLevel(logging.INFO)

    if args.verbose:
        streamer.setLevel(logging.DEBUG)
    else:
        print("--verbose for details of the packing process", file=sys.stderr)
    logger.debug("Execution line:     "+" ".join(sys.argv))


    #Path to local Packmol installation (http://www.ime.unicamp.br/~martinez/packmol/home.shtml)
    rep = "data"
    lib = "lib"
    run = args.notrun
    if args.apl_exp:
        apl = "APL_EXP"
    else:
        apl = "APL_FF"
    packmol_inc = os.path.join(script_path, lib, "packmol", "packmol" + exe_suffix)
    if args.packmol is None:
        try:
            amberhome = os.environ['AMBERHOME']
            packmol_amb = os.path.join(amberhome, "bin", "packmol" + exe_suffix)
        except:
            packmol_amb = ""

        if os.path.exists(packmol_inc):
            packmol = packmol_inc
        elif os.path.exists(packmol_amb):
            packmol = packmol_amb
        else:
            packmol = ""
    else:
        packmol = args.packmol

    if (packmol != None or packmol != "") and not os.path.exists(packmol):
        miss = "Packmol path defined but not found on "+packmol
        logger.info("\n"+len(miss)*"#"+"\n"+miss+"\n"+len(miss)*"#"+"\n")
        run = False
    elif packmol == None or packmol == "":
        miss = "Packmol path not defined. Execution will only create the packmol input script."
        logger.info("\n"+len(miss)*"#"+"\n"+miss+"\n"+len(miss)*"#"+"\n")
        run = False


    ############## PARSE PARAMS FROM REP #########

    def is_number(num):
        try:
            float(num)
            return True
        except:
            return False

    pdbtar = tarfile.open(os.path.join(script_path, rep,"pdbs.tar.gz"),"r:gz")
    parms = open(os.path.join(script_path, rep, "memgen.parm"), "r")
    parmlines = parms.readlines()
    parms.close()
    if args.memgen_parm is not None:
        logger.debug("Loading custom memgen.parm:     "+args.memgen_parm)
        logger.debug("Parameters will be extended or overwritten over default values")
        parms = open(args.memgen_parm, "r")
        parmlines += parms.readlines()
        parms.close()
    parameters = {}
    ext_par = False
    for line in parmlines:
        if line[0] == "#":
            if line.startswith("#EXTENDED LIPIDS"):
                ext_par = True
            continue
        else:
            values = line.split()
            parameters[values[0]]  = {}
            parameters[values[0]].update({
                                     "p_atm":values[1],
                                     "t_atm":values[2],
                                     "APL_FF":values[3],
                                     "APL_EXP":values[4],
                                     "V":values[5],
                                     "charge":values[6],
                                     "h_bound":values[7],
                                     "t_bound":values[8],
                                     "C":values[9],
                                     "VH":values[10],
                                     "charmm":values[11],
                                     "name":values[12],
                                     "ext":ext_par
                                     })

    if args.available_lipids or args.available_lipids_all:
        if args.memgen_parm is not None:
            logger.debug("List will include parameters in the parsed parameter file!: "+args.memgen_parm)
        if args.available_lipids:
            pformat = "{:<9}{:>6}{:>70}"
        else:
            pformat = "{:<9}{:>6}{:>130}"
        table_header= (pformat+"{:>15}").format("Lipid","Charge","Full-name","Comment")
        print("\n"+table_header, file=sys.stderr)
        print("-"*len(table_header), file=sys.stderr)
        for key in sorted(parameters):
            if not args.available_lipids_all and parameters[key]["ext"]:
                continue
            elif is_number(key[0]) or key[-2:]=="CL" or "PI" in key or parameters[key]["ext"]:
                print((pformat+" ***Parameters from PACKMOL-Memgen Lipid_ext").format(key,parameters[key]["charge"],parameters[key]["name"]))
            elif key[-2:] == "SM":
                print((pformat+" ***Only available with Lipid21").format(key,parameters[key]["charge"],parameters[key]["name"]))
            elif key.startswith("si"):
                print((pformat+" ***Only available with SIRAH").format(key,parameters[key]["charge"],parameters[key]["name"]))
            else:
                print(pformat.format(key,parameters[key]["charge"],parameters[key]["name"]))
        exit()


    solvent_parms = open(os.path.join(script_path, rep, "solvent.parm"), "r")
    sparmlines = solvent_parms.readlines()
    solvent_parms.close()
    if args.solvent_parm is not None:
        logger.debug("Loading custom solvent.parm:     "+args.solvent_parm)
        solvent_parms = open(args.solvent_parm, "r")
        sparmlines += solvent_parms.readlines()
        solvent_parms.close()
    sparameters = {}
    for line in sparmlines:
        if line[0] == "#":
            continue
        values = line.split()
        sparameters[values[0]]  = {}
        sparameters[values[0]].update({
                                 "density":values[1],
                                 "MW":values[2],
                                 "charge":values[3],
                                 "name":values[4],
                                 "source":values[5].replace("_"," ") if len(values) == 6 else "-"
                                 })

    if args.available_solvents:
        pformat = "{:<9}{:>15}{:>15}{:>15}{:>40}{:>80}"
        table_header= pformat.format("Solvent","Density [g/cm3]","MW [g/mol]","Charge","Full-name","Comments")
        print("\n"+table_header, file=sys.stderr)
        print("-"*len(table_header), file=sys.stderr)
        for key in sorted(sparameters):
            print(pformat.format(key,sparameters[key]["density"],sparameters[key]["MW"],sparameters[key]["charge"],sparameters[key]["name"],sparameters[key]["source"]))
        exit()



    ############ ARGPARSE ARGUMENTS ###################

    if args.curv_radius is not None:
        args.curvature = 1/args.curv_radius

    if args.curvature is not None:
        sphere_radius = 1/args.curvature
        if args.vol:
            logger.critical("CRITICAL:\n  --vol and curvature are not compatible!")
            exit()
        if args.solvate:
            logger.critical("CRITICAL:\n  --solvate and curvature are not compatible!")
            exit()

    if not args.solvate and args.cubic:
        logger.warning("WARNING:--cubic only available with --solvate. Turned off!")
        args.cubic = False

    if args.solvate:
        args.preoriented = True
        z_cen = True
        pdb_prefix = "solvated"
        args.dist_wat = args.dist
    else:
        pdb_prefix = "bilayer"
        z_cen = False

    if args.ffwat is None:
        if args.ffprot == "ff15ipq":
            args.ffwat = "spceb"
        elif args.ffprot == "ff19SB":
            args.ffwat = "opc"
        elif args.ffprot == "ff14SB":
            args.ffwat = "tip3p"
        logger.debug("Water model was not set. Using %s for %s" % (args.ffwat, args.ffprot))

    leaflet_z = args.leaflet # leaflet thickness
    lip_offset = args.lip_offset
    bound_tail = args.tailplane # plane that defines boundary to last carbon in aliphatic chain
    bound_head = args.headplane # plane that defines boundary to polar head
    lipids = args.lipids # lipids to be used
    extended = False

    onlymembrane = False
    if args.pdb is None or args.pdb.count("None") == len(args.pdb):
        onlymembrane = True
    else:
        for pdb in args.pdb:
            if not (pdb.endswith(".pdb") or pdb.endswith(".pqr")):
                logger.critical("CRITICAL:\n  The input file can only be in PDB or PQR formats.")
                exit()
    if args.double_span and args.pdb is None:
        logger.critical("CRITICAL:\n  --double_span requires a PDB file as input")
        exit()
    elif args.double_span and len(args.pdb) == 1:
        args.pdb.append("None")

    if args.minimize:
        args.parametrize = True

    outfile = args.output
    if outfile is not None:
        if not outfile.endswith(".pdb"):
            outfile = outfile+".pdb"
    if not args.output and args.pdb is None:
        outfile = pdb_prefix+"_only.pdb"
    elif not args.output:
        outfile = pdb_prefix+"_"+"".join([os.path.basename(pdb)[:-4] for pdb in args.pdb])+".pdb"

    if lipids is not None:
        if any([parameters[l]["ext"] for lipid in lipids for leaf in lipid.split("//") for l in leaf.split(":")]):
            logger.info("The Lipid Force Field extension lipid_ext is required for this system! Use --parametrize to get it done for you")
            extended = True
    saltcon = args.saltcon # salt concentration in M
    if not args.salt:
        if "--saltcon" in sys.argv and (args.distxy_fix is not None or args.pdb is not None):
            logger.error("ERROR:\n    You specified a salt concentration, but not the salt flag. Only neutralizing ions will be added")
        saltcon = 0
        if args.charge_imbalance != 0:
            logger.error("ERROR:\n    You specified a charge imbalance, but not the salt flag. No charge imbalance will be applied")
    override_salt = args.salt_override
    #Check for cation
    if args.sirah:
        ion_dict = {"K+":("siKW",1,"KW"),"Na+":("siNaW",1,"NaW"),"Ca2+":("siCaX",2,"CaX"),"Cl-":("siClW",-1,"ClW")}
    else:
        ion_dict = {"K+":("POT",1,"K+"),"Na+":("SOD",1,"Na+"),"Ca2+":("CAL",2,"CA"),"Cl-":("CLA",-1,"Cl-"),"Mg2+":("MG",2,"MG")}
    if args.salt_c not in ion_dict:
        logger.error("ERROR:\n    The specified cation option is no available at the moment")
        exit()
    else:
        cation = ion_dict[args.salt_c][0]
    args.salt_a = "Cl-"
    anion = ion_dict[args.salt_a][0] #Maybe more alternatives at some point? ILs?
    distance = args.dist # distance from the protein to the box boundaries to XY
    distance_wat = args.dist_wat # minimum distance from the surface of the membrane to the box boundary on Z

    if (args.distxy_fix is not None and args.dims != [0,0,0]):
        logger.error("ERROR:\n    --distxy_fix and --dims should not be used together! Use -h for help.")
        exit()

    asym = False
    if args.distxy_fix is not None and args.dims == [0,0,0]:
        args.dims = [args.distxy_fix,args.distxy_fix,0]
    elif args.dims == [0,0,0]:
        args.dims = None
    else:
        asym = True

    if (args.distxy_fix is None and args.dims is None) and onlymembrane:
        logger.error("ERROR:\n    No PDB file given or fixed XY dimensions specified. Check --distxy_fix and --dims for help (-h/--help).")
        exit()
    nloop = args.nloop
    nloop_all = args.nloop_all
    if args.writeout is None:
        if int(nloop) < 10 or int(nloop_all) < 10:
            logger.error("ERROR:\n    nloop and nloop_all have to be bigger than the writeout frequency (every 10 loops by default). You can modify this with --writeout")
            exit()
    else:
        if int(nloop) < int(args.writeout) or int(nloop_all) < int(args.writeout):
            logger.error("ERROR:\n    nloop and nloop_all have to be bigger than the writeout frequency! Modify the used values.")
            exit()
    protonate = args.notprotonate
    Trim = args.nottrim
    grid_calc = args.notgridvol
    delete = args.keep
    onlydots = args.noprogress

    # JSwails suggestion//Check if in a tty. Turn off progress bar if that's the case.
    if not os.isatty(sys.stdin.fileno()):
        onlydots = True

    # Make a list with created files for later deletion
    created        = []
    created_notrun = []

    ###############################################
    ###############################################
    ###############################################

    ############ SEARCH AMBER, LIBS, PDB, MEMEMBED ###################

    try:
        amberhome = os.environ['AMBERHOME']
        reduce = os.path.join(amberhome, "bin", "reduce" + exe_suffix)
        if not os.path.exists(reduce):
            logger.warning("WARNING:AMBER path found, but reduce executable is not available")
    except:
        amberhome = None
        reduce = None
        logger.debug("AMBER environment variables not found. Protonation will not be available!")

    if not os.path.exists(os.path.join(script_path, rep)):
        logger.critical("CRITICAL:\n  The data folder for using the script is missing. Check the path for the script!")
        exit()

    # Check if lipid21 was already added
    if not os.path.exists(os.path.join(amberhome, "dat" , "leap" , "cmd" , "leaprc.lipid21")) and args.fflip == "lipid21":
        logger.info("Lipid21 was not found in AMBERHOME. Falling back to lipid17!")
        args.fflip = "lipid17"

    if args.pdb is not None:
        if args.pdb[0] == "None" and not onlymembrane:
            logger.error("ERROR:\n    Please specify first the protein PDB file!")
            exit()
        for pdb in args.pdb:
            if not os.path.exists(pdb) and pdb != "None":
                logger.error("ERROR:\n    Either the options were wrongly used or the file "+pdb+" doesn't exist!")
                exit()

    memembed_inc = os.path.join(script_path, lib, "memembed", "bin", "memembed" + exe_suffix)
    if args.memembed is None:
        try:
            amberhome = os.environ['AMBERHOME']
            memembed_amb = os.path.join(amberhome, "bin", "memembed" + exe_suffix)
        except:
            memembed_amb = ""

        if os.path.exists(memembed_inc):
            memembed = memembed_inc
        elif os.path.exists(memembed_amb):
            memembed = memembed_amb
        else:
            memembed = ""
    else:
        memembed = args.memembed

    if not os.path.exists(memembed):
        miss = "MEMEMBED not found. The system will be built assuming it was preoriented"
        logger.warning(logger.info("\n"+len(miss)*"#"+"\n"+miss+"\n"+len(miss)*"#"+"\n"))
        memembed = False

    if not os.path.exists(os.path.join(script_path, lib, "pdbremix")):
        logger.warning("WARNING:PDBREMIX lib not available. Volume estimation will be done based on estimated density")
    else:
        grid_avail = True

    if args.solvents is None:
        args.solvents = "WAT"
    if len(args.solvents.split(":")) == 1:
        args.solvent_ratio = "1"
    elif len(args.solvents.split(":")) > 1 and args.solvent_ratio is None:
        logger.error("ERROR:\n    If using solvent mixtures, a solvent ratio has to be specified")
        exit()
    if len(args.solvents.split(":")) != len(args.solvent_ratio.split(":")):
        logger.error("ERROR:\n    Amount of solvent types and solvent ratios doesn't fit! Check your input")
        exit()

    if args.sirah:
        logger.info("Using parameters to pack a SIRAH system")
        args.solvents = "siWT4"
        args.solvent_ratio = "1"
        args.tight_box = True
        if "--prot_rad" not in sys.argv:
            args.prot_rad = 2
        if "--tolerance" not in sys.argv:
            args.tolerance = 3

    for solvent in args.solvents.split(":"):
        if solvent not in sparameters:
            logger.error("ERROR:\n    Selected solvent %s parameters not available. Check --available_solvents" % (solvent))
            exit()

    solvent_ratios = [float(ratio) for ratio in args.solvent_ratio.split(":")]
    solvent_density = sum([float(sparameters[solvent]["density"])*solvent_ratios[i] for i, solvent in enumerate(args.solvents.split(":"))])/sum(solvent_ratios)
    solvent_con     = sum([(solvent_ratios[i]*float(sparameters[solvent]["density"])*avogadro)/(float(sparameters[solvent]["MW"])*10**24) for i, solvent in enumerate(args.solvents.split(":"))])/sum(solvent_ratios)

    if lipids is None:
        lipids = ["DOPC"]
    if args.double and len(lipids) == 1:
        lipids = lipids+["//".join(reversed(lipids[0].split("//")))]
    elif args.double and len(lipids) != 1:
        logger.error("ERROR:\n    --double requires a single definition of lipid composition")
        exit()
    if args.double_span and len(lipids) != 2:
        logger.error("ERROR:\n    --double_span requires a definition of lipid composition per bilayer")
        exit()
    if args.ratio is None:
        logger.info("No ratio provided (--ratio).")
        args.ratio  = ["1"]*len(lipids)
    if args.double and len(lipids) == 2 and len(args.ratio) == 1:
        args.ratio = args.ratio+["//".join(reversed(args.ratio[0].split("//")))]

    if len(lipids) != len(args.ratio):
        logger.error("ERROR:\n    Number of defined bilayer lipids and ratios doesn't fit! Check your input")
        exit()

    if args.n_ter is None and args.double:
        args.n_ter = ["in","out"]
    elif args.n_ter is None:
        args.n_ter = ["in"]*len(lipids)

    elif len(args.n_ter) != len(args.pdb):
        logger.error("ERROR:\n    Number of specified orientations and bilayers doesn't fit! Check your input")
        exit()
    else:
        for n, pdb in enumerate(args.pdb):
            if pdb != "None" and not (args.n_ter[n] == "in" or args.n_ter[n] == "out"):
                logger.error("ERROR:\n    The orientation has to be 'in' or 'out' unless pdb is 'None'")
                exit()

    if args.solute_prot_dist is not None and onlymembrane:
        logger.error("ERROR:\n    A solute distance can only be specified with respect to an included PDB!")
        exit()

    if args.channel_plug is not None and onlymembrane:
        logger.error("ERROR:\n    A channel plug can only be specified with respect to an included PDB!")
        exit()

    if args.solute_charge is None and args.solute is not None:
        args.solute_charge = [0]*len(args.solute)

    elif args.solute_charge is not None and args.solute is not None:
        if len(args.solute_charge) != len(args.solute):
            logger.error("ERROR:\n    Number of specified solute charges and solutes doesn't fit! Check your input")
            exit()
        else:
            for n, solute in enumerate(args.solute):
                try:
                    args.solute_charge[n] = int(args.solute_charge[n])
                except:
                    logger.error("ERROR:\n    Solute charges have to be integers")
                    exit()
    apl_offset   = {}
    composition  = {}
    sterols_used = False
    for bilayer in range(len(lipids)):
        apl_offset[bilayer]  = {}
        composition[bilayer] = {}
        if "//" in lipids[bilayer]:
            if len(lipids[bilayer].split("//")) != 2 or len(args.ratio[bilayer].split("//")) != 2:
                logger.error("ERROR:\n    If different leaflet compositions used, ratios have to be specified explicitly, and both must be separated by one '//' only!")
                exit()
            for leaflet in range(2):
                if len(lipids[bilayer].split("//")[leaflet].split(":")) != len(args.ratio[bilayer].split("//")[leaflet].split(":")):
                    logger.error("ERROR:\n    Amount of lipid types and ratios doesn't fit! Check your input")
                    exit()
                apl_offset[bilayer][leaflet] = {}
                if args.apl_offset is None:
                    apl_offset[bilayer][leaflet] = 1.0
                elif len(args.apl_offset) != len(lipids):
                    logger.error("ERROR:\n    If apl_offset is specified, it has to be set once per bilayer")
                elif "//" in args.apl_offset[bilayer]:
                    apl_offset[bilayer][leaflet] = float(args.apl_offset[bilayer].split("//")[leaflet])
                else:
                    apl_offset[bilayer][leaflet] = float(args.apl_offset[bilayer])
                composition[bilayer][leaflet]={}
                ratio_total = sum([float(x) for x in args.ratio[bilayer].split("//")[leaflet].split(":")])
                for n, lipid in enumerate(lipids[bilayer].split("//")[leaflet].split(":")):
                    if (lipid == "PSM" or lipid == "SSM") and args.fflip == "lipid17":
                        logger.warning("WARNING:LIPID17 doesn't currently support sphingomyelin! AMBER parametrization will be disabled.")
                        args.minimize    = False
                        args.parametrize = False
                    if args.sirah:
                        composition[bilayer][leaflet]["si"+lipid] = float(args.ratio[bilayer].split("//")[leaflet].split(":")[n])/ratio_total
                    else:
                        composition[bilayer][leaflet][lipid] = float(args.ratio[bilayer].split("//")[leaflet].split(":")[n])/ratio_total
        else:
            if len(lipids[bilayer].split(":")) != len(args.ratio[bilayer].split(":")):
                logger.error("ERROR:\n    Amount of lipid types and ratios doesn't fit! Check your input")
                exit()
            if args.apl_offset is None:
                apl_offset[bilayer][0] = apl_offset[bilayer][1] = 1.0
            elif len(args.apl_offset) != len(lipids):
                logger.error("ERROR:\n    If apl_offset is specified, it has to be set once per bilayer")
            elif "//" in args.apl_offset[bilayer]:
                apl_offset[bilayer][0], apl_offset[bilayer][1] = map(float,args.apl_offset[bilayer].split("//"))
            else:
                apl_offset[bilayer][0] = apl_offset[bilayer][1] = float(args.apl_offset[bilayer])
            composition[bilayer][0]={} ; composition[bilayer][1]={}
            ratio_total = sum([float(x) for x in args.ratio[bilayer].split(":")])
            for n, lipid in enumerate(lipids[bilayer].split(":")):
                if (lipid == "PSM" or lipid == "SSM") and args.fflip == "lipid17":
                    logger.warning("WARNING:LIPID17 doesn't currently support sphingomyelin! AMBER parametrization will be disabled.")
                    args.minimize    = False
                    args.parametrize = False
                if args.sirah:
                    composition[bilayer][0]["si"+lipid] = composition[bilayer][1]["si"+lipid] = float(args.ratio[bilayer].split(":")[n])/ratio_total
                else:
                    composition[bilayer][0][lipid] = composition[bilayer][1][lipid] = float(args.ratio[bilayer].split(":")[n])/ratio_total

    for key in [x for leaflet in composition[bilayer] for bilayer in composition for x in composition[bilayer][leaflet]]:
        if key in sterols:
            sterols_used = True
        if key not in parameters:
            logger.critical("CRITICAL:\n  Parameters missing for "+key+". Please check the file memgen.parm")
            exit()
        if args.charmm and parameters[key]["charmm"] == "N":
            logger.critical("CRITICAL:\n  Lipid "+key+" not available in CHARMM format.")
            exit()
        if not os.path.exists(os.path.join(script_path, rep, "pdbs", key +".pdb")) and key+".pdb" not in pdbtar.getnames():
            logger.warning("WARNING:\n  PDB file for "+key+" not found in repo!")
            if not os.path.exists(key+".pdb"):
                logger.critical("CRITICAL:\n  PDB file for "+key+" not found in local folder!")
                exit()

    if not onlymembrane:
        if len(composition) != len(args.pdb):
            if args.double and len(composition) == 2 and len(args.pdb) == 1:
                logger.debug("Using the pdb file for both bilayers")
                args.pdb = args.pdb*2
            else:
                logger.critical("CRITICAL:\n  The number of provided PDB files doesnt fit with the number of bilayers. Pass --pdb \"None\" if you want an empty bilayer.")
                exit()

    if args.solute is not None:
        if args.solute_con is not None:
            if len(args.solute) != len(args.solute_con):
                logger.critical("CRITICAL:\n  Number of solutes and concentrations/number of molecules is not the same! Please provide a concentration for each solute in the respective order.")
                exit()
        else:
            logger.error("ERROR:\n    Concentrations/number of molecules have to be provided.")
            exit()


    if args.ligand_param is not None:
        for param in args.ligand_param:
            files = param.split(":")
            if not os.path.exists(files[0]) or not os.path.exists(files[1]):
                logger.error("ERROR:\n    Specified parameter files do not exist!")
                logger.debug("Files: "+" ".join(files))
                exit()

    ############## SET OF USED FUNCTIONS  #####################

    def estimated_density(MW):
        density = 1.41 + 0.145*math.exp(float(-MW)/13000)  #Protein Sci. 2004 Oct; 13(10):2825-2828
        return density

    def memembed_align(pdb,keepligs=False,double_span=False,verbose=False,overwrite=False,barrel=False,n_ter="in",opt="3"):
        output = pdb[:-4]+n_ter+"_EMBED.pdb"
        if not os.path.exists(output):
            if not barrel:
                os.system(memembed+" -s "+opt+" -n "+n_ter+" -o "+output+" "+pdb+" > "+output.replace("_EMBED.pdb","_memembed.log"))
            else:
                os.system(memembed+" -s "+opt+" -b -n "+n_ter+" -o "+output+" "+pdb+" > "+output.replace("_EMBED.pdb","_memembed.log"))
        if keepligs:
            if verbose:
                logger.info("Superimposing to keep ligands")
            rmsd_of_pdbs(pdb,output,transform_pdb1=output.replace("_EMBED.pdb","_EMBED_ligs.pdb"), standard=True)
            output = output.replace("_EMBED.pdb","_EMBED_ligs.pdb")
            return output
        if double_span:
            outpdb = pdb_parse(output, onlybb=False)
            low_bound = np.mean([outpdb[res][atom] for res in outpdb.keys() if res[0] == "DUM" for atom in outpdb[res] if atom[0] == "N" ], axis=0)
            up_bound  = np.mean([outpdb[res][atom] for res in outpdb.keys() if res[0] == "DUM" for atom in outpdb[res] if atom[0] == "O" ], axis=0)
            offset = 0
            mem1_cen  = np.mean([low_bound, up_bound], axis=0)
            tmless                  = {res:outpdb[res] for res in outpdb.keys() if not any([outpdb[res][atom][2] >= low_bound[2]-offset and outpdb[res][atom][2] <= up_bound[2]+offset for atom in outpdb[res]])}
            tmless[('MEM', 1, 'X')] = {('MEM', 1): mem1_cen}
            pdb_write(tmless, outfile="temp1.pdb")
            if not barrel:
                os.system(memembed+" -s "+opt+" -n "+n_ter+" -o temp2.pdb temp1.pdb > double_span.log")
            else:
                os.system(memembed+" -s "+opt+" -b -n "+n_ter+" -o temp2.pdb temp1.pdb > double_span.log")

            temppdb = pdb_parse("temp2.pdb", onlybb=False)
            low_bound = np.mean([temppdb[res][atom] for res in temppdb.keys() if res[0] == "DUM" for atom in temppdb[res] if atom[0] == "N" ], axis=0)
            up_bound  = np.mean([temppdb[res][atom] for res in temppdb.keys() if res[0] == "DUM" for atom in temppdb[res] if atom[0] == "O" ], axis=0)
            offset = 5
            mem2_cen  = np.mean([low_bound, up_bound], axis=0)
            dumless                  = {res:temppdb[res] for res in temppdb.keys() if res[0] != "DUM"}
            dumless[('MEM', 2, 'X')] = {('MEM', 2): mem2_cen}
            z_dist = dumless[('MEM', 1, 'X')][('MEM', 1)][2]+dumless[('MEM', 2, 'X')][('MEM', 2)][2]
#            print(z_dist)
            if z_dist < 0:
                dumless = translate_pdb(dumless,vec=[0,0,z_dist])
                z_dist *= -1

            pdb_write(dumless,outfile="presuper.pdb")

            translated = superimpose_pdb(dumless,outpdb)

#            translated[('MEM', 1, 'X')] = dumless[('MEM', 1, 'X')]
#            translated[('MEM', 2, 'X')] = dumless[('MEM', 2, 'X')]
            pdb_write(translated, outfile=output.replace("EMBED","EMBED_double"))
            return (output.replace("EMBED","EMBED_double"), z_dist)

        return output


    def pdbvol(pdb,spacing=0.5,overwrite=False):
        output = pdb[:-4]+".grid.pdb"
        if os.path.exists(output) and not overwrite:
            filelength = len(open(output,"r").readlines())
            vol        = filelength*spacing**3
            return (output, vol)
        else:
            filelines = open(pdb,"r").readlines()
            temp_pdb = []
            for line in filelines:
                if (line[0:4] == "ATOM" or line[0:6] == "HETATM") and  line[17:20].strip() != "DUM":
                    temp_pdb.append(line)
            temp = open("temp.pdb","w").writelines(temp_pdb)
            atoms = pdbatoms.read_pdb("temp.pdb")
            pdbatoms.add_radii(atoms)
            vol = volume(atoms, spacing, output, verbose=False)
            os.remove("temp.pdb")
            return (output, vol)

    if args.solute is not None:
        for i, sol in enumerate(args.solute):
            if not os.path.exists(args.solute[i]):
                logger.error(args.solute[i]+" not found!")
                exit()
            logger.info("Extra solute PDB         = %-9s" % (args.solute[i]))
            logger.info("Solute to be added       = %-9s" % (args.solute_con[i]))



#if os.path.exists(outfile) and not args.overwrite:
#    logger.info("Packed PDB "+outfile+" found. Skipping PACKMOL")
#else:
    ############################### SCRIPT HEADER ################################

    content_header = content_prot = content_lipid = content_solvent = content_ion = content_solute = ""
    content_header += "tolerance "+str(args.tolerance)+"\n"
    content_header += "filetype pdb\n"
    content_header += "output "+outfile+"\n\n"
    if args.writeout is not None:
        content_header += "writeout "+args.writeout+"\n"
    if args.traj:
        if args.writeout is None:
            content_header += "writeout 1\n"
        content_header += "writebad\n\n"

    if args.random:
        content_header += "seed -1\n"
    if args.packall:
        content_header += "packall\n"
    if not args.charmm:
         content_header += "add_amber_ter\n"
    if args.movebadrandom:
        content_header += "movebadrandom\n"

    content_header += "nloop "+str(nloop_all)+"\n\n"
#    content_header += "nloop_all "+str(nloop_all)+"\n\n"

    pond_lip_vol_dict      = {}
    pond_lip_apl_dict      = {}
    lipnum_dict            = {}
    lipnum_area_dict       = {}

    X_min   = X_max = X_len = Y_min = Y_max = Y_len = 0
    Z_dim   = []
    memvol  = []
    solvol  = []
    charges = []
    if not onlymembrane:
        chain_nr = 0
        chain_index = list(string.ascii_uppercase)
        for n,pdb in enumerate(args.pdb):
            if pdb != "None":
                if not args.verbose:
                    logger.info("Preprocessing "+pdb+". This might take a minute.")
                if protonate and reduce:
                    logger.debug("Using 'reduce' to protonate...")
                    if Trim:
                        logger.debug("Trimming preexisting protons...")
                        pdb =  reduce_trim(pdb,overwrite=args.overwrite)
                        if pdb == "error":
                            logger.error("ERROR:\n    reduce returned an empty file! Check the used pdb files and reduce_Trim_warn.log")
                            exit()
                        created.append(pdb)
                        created.append("reduce_Trim_warn.log")
                    logger.debug("Adding protons...")
                    pdb =  reduce_protonate(pdb,overwrite=args.overwrite,build=args.reducebuild)
                    if pdb == "error":
                            logger.error("ERROR:\n    reduce returned an empty file! Check the used pdb files and reduce_warn.log")
                            exit()
                    created.append(pdb)
                    created.append("reduce_warn.log")

                if not args.preoriented and memembed:
                    logger.debug("Orienting the protein using MEMEMBED...")
                    created.append(pdb+"_memembed.log")
                    if args.double_span:
                        pdb, z_offset_ds = memembed_align(pdb,keepligs=args.keepligs,verbose=args.verbose,overwrite=args.overwrite,barrel=args.barrel,n_ter=args.n_ter[n],opt=args.mem_opt, double_span=True)
                        z_offset_ds = np.abs(z_offset_ds)
                        pdb_ds = pdb
                    else:
                        pdb = memembed_align(pdb,keepligs=args.keepligs,verbose=args.verbose,overwrite=args.overwrite,barrel=args.barrel,n_ter=args.n_ter[n],opt=args.mem_opt)
                    created.append(pdb)
                elif args.preoriented and args.double_span:
                    ds_oriented = pdb_parse(pdb, onlybb=False)
                    try:
                        z_dist = ds_oriented[('MEM', 1, 'X')][('MEM', 1)][2]+ds_oriented[('MEM', 2, 'X')][('MEM', 2)][2]
                    except:
                        logger.critical("CRITICAL:\n  If using a preoriented double spanning PDB, it has to include MEM atoms!")
                        exit()
                    if z_dist < 0:
                        ds_oriented = translate_pdb(ds_oriented,vec=[0,0,z_dist])
                        z_dist *= -1
                    del ds_oriented[('MEM', 1, 'X')]
                    del ds_oriented[('MEM', 2, 'X')]

                    pdb_write(ds_oriented, outfile="ds_temp.pdb")
                    pdb = pdb_ds = "ds_temp.pdb"

                    z_offset_ds = z_dist


                if grid_calc:
                    logger.debug("Estimating the volume by building a grid (PDBREMIX)...")
                    grid = pdbvol(pdb)
                    created.append(grid[0])
                else:
                    grid = (None,None)

                ############## FAST VALUE ESTIMATION FROM PDB #####################
                minmax, max_rad, charge_prot, vol, memvol_up, memvol_down, solvol_up, solvol_down, density, mass, chains = measure_parms(pdb,leaflet_z,grid[0],move=True, move_vec=args.translate, xy_cen=args.noxy_cen, z_cen=z_cen, outpdb="PROT"+str(n)+".pdb",chain=chain_index[chain_nr],renumber=True)
                if args.sirah:
                    sirah_cgconv("PROT"+str(n)+".pdb")
                chain_nr += chains
                charges.append(charge_prot)
                if args.double:
                    minmax, max_rad, charge_prot, vol, memvol_up, memvol_down, solvol_up, solvol_down, density, mass, chains = measure_parms(pdb,leaflet_z,grid[0],move=True, move_vec=args.translate, xy_cen=args.noxy_cen, z_cen=z_cen, outpdb="PROT"+str(n+1)+".pdb",chain=chain_index[chain_nr],renumber=True)
                    if args.sirah:
                        sirah_cgconv("PROT"+str(n)+".pdb")
                    chain_nr += chains
                    charges.append(charge_prot)


            elif pdb == "None" and args.double_span:
                logger.debug("Estimating for second mem!")
                minmax, max_rad, charge_prot, vol, memvol_up, memvol_down, solvol_up, solvol_down, density, mass, chains = measure_parms(pdb_ds,leaflet_z,grid[0],move=True, move_vec=[0,0,z_offset_ds], xy_cen=args.noxy_cen, z_cen=z_cen, outpdb="PROT"+str(n)+".pdb",chain=chain_index[chain_nr],renumber=True)
                if args.sirah:
                    sirah_cgconv("PROT"+str(n)+".pdb")


            else:
                if not args.verbose:
                    logger.debug("Building membrane without protein!")
                if args.dims is not None:
                    minmax      = [-args.dims[0]/2,-args.dims[1]/2,-leaflet_z,args.dims[0]/2,args.dims[1]/2,leaflet_z]
                #TEST!!!
                else:
                    minmax      = minmax[0:2]+[-leaflet_z]+minmax[3:5]+[leaflet_z]
                charge_prot      = 0
                charges.append(charge_prot)
                vol              = 0
                memvol_up        = 0
                memvol_down      = 0
                solvol_up        = 0
                solvol_down      = 0
                density          = 0
                mass             = 0

            solvol.append((solvol_down,solvol_up))
            memvol.append((memvol_down,memvol_up))
            if args.double:
                memvol.append((memvol_down,memvol_up))

            if args.double_span and pdb == "None":
                charges.append(0)
                Z_dim.append((-z_offset_ds/2,z_max-z_offset_ds,z_max-z_offset_ds/2))
                continue

            com = [(minmax[0]+minmax[3])/2,(minmax[1]+minmax[4])/2,(minmax[2]+minmax[5])/2]

            if args.dims is not None:
                pdbx_min     = com[0]-args.dims[0]/2
                pdbx_max     = com[0]+args.dims[0]/2
                pdby_min     = com[1]-args.dims[1]/2
                pdby_max     = com[1]+args.dims[1]/2
                pdbz_min     = com[2]-args.dims[2]/2
                pdbz_max     = com[2]+args.dims[2]/2

            else:
                pdbx_min     = minmax[0]
                pdbx_max     = minmax[3]
                pdby_min     = minmax[1]
                pdby_max     = minmax[4]
                pdbz_min     = minmax[2]
                pdbz_max     = minmax[5]

            pdbx_len     = pdbx_max-pdbx_min
            pdby_len     = pdby_max-pdby_min
            pdbz_len     = pdbz_max-pdbz_min

            if not asym:
                if args.dims is None:
    #                max_side_len = math.sqrt(pdbx_len**2+pdby_len**2)+2*distance
                    max_side_len = 2*max_rad+2*distance
                else:
                    max_side_len = max(args.dims[:2])
                if args.cubic:
                    max_side_len = max(max_side_len,pdbz_len+2*distance)
                diff_x       = max_side_len - pdbx_len
                diff_y       = max_side_len - pdby_len
                diff_z       = max_side_len - pdbz_len
            else:
                diff_x = diff_y = diff_z = 0
            x_min        = pdbx_min-diff_x/2
            x_max        = pdbx_max+diff_x/2
            y_min        = pdby_min-diff_y/2
            y_max        = pdby_max+diff_y/2
            z_min        = pdbz_min-diff_z/2
            z_max        = pdbz_max+diff_z/2
            x_len        = x_max-x_min
            y_len        = y_max-y_min
            z_len        = z_max-z_min

            if not args.cubic and not asym:
                z_min = pdbz_min-distance_wat
                if z_min > -(leaflet_z+distance_wat):
                    z_min = -(leaflet_z+distance_wat)
                z_max = pdbz_max+distance_wat
                if z_max < (leaflet_z+distance_wat):
                    z_max =  (leaflet_z+distance_wat)
                if args.xygauss:
                    z_max += float(args.xygauss[2])
                z_len = z_max-z_min

            if x_min < -1000 or x_max > 1000 or y_min < -1000 or y_max > 1000 or z_min < -1000 or z_max > 1000:
                logger.warning("WARNING:The size of the system is bigger than the default accepted values for PACKMOL. The flag sidemax will be added.")
                content_header += "sidemax "+str(max(abs(max(x_max,y_max,z_max)),abs(min(x_min,y_min,z_min))))+"\n"

            prot_data2= """
 Estimated values for input protein:

 Input PDB                = %-9s
 Charge                   = %-9s
 Mass                     = %-9s    Da
 Density                  = %-9s    Da/A^3
 Estimated volume         = %-9s    A^3
     in upper leaflet     = %-9s    A^3
     in lower leaflet     = %-9s    A^3
     in upper water box   = %-9s    A^3
     in lower water box   = %-9s    A^3
            """
            logger.debug(prot_data2 % ( pdb, charge_prot, mass, round(density,2), round(vol,2), round(memvol_up,2), round(memvol_down,2), round(solvol_up), round(solvol_down,2)))


            if x_len > X_len:
                X_min = x_min; X_max = x_max; X_len = x_len
            if y_len > Y_len:
                Y_min = y_min; Y_max = y_max; Y_len = y_len
            if args.double_span and pdb != "None":
                Z_dim.append((z_min,z_offset_ds/2,z_offset_ds/2-z_min))
            else:
                Z_dim.append((z_min,z_max,z_len))
            if args.double:
                Z_dim.append((z_min,z_max,z_len))
                break
    else:
        if args.dims is not None:
            minmax      = [-args.dims[0]/2,-args.dims[1]/2,-args.dims[2]/2,args.dims[0]/2,args.dims[1]/2,args.dims[2]/2]
            z_min = minmax[2]
            z_max = minmax[5]
        else:
            z_min = minmax[2]-distance_wat
            z_max = minmax[5]+distance_wat

        charge_prot      = 0
        charges          = [charge_prot]*len(composition)
        vol              = 0
        memvol_up        = 0
        memvol_down      = 0
        solvol_up        = 0
        solvol_down      = 0
        density          = 0
        mass             = 0

        memvol = [(memvol_down,memvol_up)]*len(composition)
        solvol = [(solvol_down,solvol_up)]*len(composition)

        pdbx_len     = minmax[3]-minmax[0]
        pdby_len     = minmax[4]-minmax[1]

        if not asym:
            max_side_len = max(pdbx_len,pdby_len)
            diff_x       = max_side_len - pdbx_len
            diff_y       = max_side_len - pdby_len
        else:
            diff_x = diff_y = 0
        x_min        = minmax[0]-diff_x/2
        x_max        = minmax[3]+diff_x/2
        y_min        = minmax[1]-diff_y/2
        y_max        = minmax[4]+diff_y/2
        x_len        = x_max-x_min
        y_len        = y_max-y_min


        if not args.solvate:
            if z_min > -(leaflet_z+distance_wat):
                z_min = -(leaflet_z+distance_wat)
            if z_max < (leaflet_z+distance_wat):
                z_max =  (leaflet_z+distance_wat)
            if args.xygauss:
                z_max += float(args.xygauss[2])
        z_len = z_max-z_min

        if x_min < -1000 or x_max > 1000 or y_min < -1000 or y_max > 1000 or z_min < -1000 or z_max > 1000:
            logger.warning("WARNING:The size of the system is bigger than the default accepted values for PACKMOL. The flag sidemax will be added.")
            content_header += "sidemax "+str(max(abs(max(x_max,y_max,z_max)),abs(min(x_min,y_min,z_min))))+"\n"

        if x_len > X_len:
            X_min = x_min; X_max = x_max; X_len = x_len
        if y_len > Y_len:
            Y_min = y_min; Y_max = y_max; Y_len = y_len
        Z_dim = [(z_min,z_max,z_len)]*len(composition)

    prot_data1 = """
 Information for packing:

 Input PDB(s)                     = %-9s
 Output PDB                       = %-9s
 Packmol output and log prefix    = %-9s
 Lipids                           = %-9s
 Lipid ratio                      = %-9s
 Solvents                         = %-9s
 Solvent ratio                    = %-9s
 Salt concentration            (M)= %-9s
 Distance to boundaries        (A)= %-9s
 Minimum water distance        (A)= %-9s
 Packmol loops                    = %-9s
 Packmol loops for All-together   = %-9s"""

    if not args.solvate:
        logger.info(prot_data1 % ( args.pdb, outfile, args.packlog, lipids, args.ratio, args.solvents, args.solvent_ratio, saltcon, distance, distance_wat, nloop, nloop_all))
    else:
        logger.info(prot_data1 % ( args.pdb, outfile, args.packlog, "-", "-", args.solvents, args.solvent_ratio, saltcon, distance, distance_wat, nloop, nloop_all))
    if args.curvature is not None:
        logger.info(" Membrane curvature          (1/A)= %-9s " % (args.curvature))
    elif args.xygauss:
        logger.info(" XY Gauss curvature (s_x,s_y,h)   = %s %s %s " % tuple(args.xygauss))

    box_info = """
 Box information:
 x_min                    = %-9s
 x_max                    = %-9s
 x_len                    = %-9s

 y_min                    = %-9s
 y_max                    = %-9s
 y_len                    = %-9s

 z_min                    = %-9s
 z_max                    = %-9s
 z_len                    = %-9s
 """
    logger.debug(box_info % ( X_min, X_max, X_len, Y_min, Y_max, Y_len, Z_dim[0][0], Z_dim[0][0]+sum([zdim[2] for zdim in Z_dim]), sum([zdim[2] for zdim in Z_dim]) ))

    if os.path.exists(outfile) and not args.overwrite:
        logger.info("Packed PDB "+outfile+" found. Skipping PACKMOL")
    else:
        z_offset = 0

        for n, bilayer in enumerate(composition):
            if bilayer > 0:
                if args.double_span:
                    z_offset = z_offset_ds
                else:
                    z_offset = z_offset+Z_dim[bilayer-1][1]-Z_dim[bilayer][0]

            ################################## PROTEIN ###################################

            if not onlymembrane:
                if args.pdb[bilayer] != "None":
                    created_notrun.append("PROT"+str(bilayer)+".pdb")
                    if args.sirah:
                        created_notrun.append("PROT"+str(bilayer)+"_cg.pdb")
                        content_prot += "structure PROT"+str(bilayer)+"_cg.pdb\n"
                    else:
                        content_prot += "structure PROT"+str(bilayer)+".pdb\n"
                    content_prot += "  number 1\n"
                    content_prot += "  fixed 0. 0. "+str(z_offset)+" 0. 0. 0.\n"
                    content_prot += "  radius "+str(args.prot_rad)+"\n"
                    content_prot += "end structure\n\n"

            ################################ LIPIDS ######################################

            if args.curvature is not None:
                lipid_vol_up           = sphere_integral_square(X_min,X_max,Y_min,Y_max,r1=sphere_radius+z_offset,r2=sphere_radius+z_offset+leaflet_z,c=-sphere_radius)-memvol[bilayer][1]
                lipid_vol_down         = sphere_integral_square(X_min,X_max,Y_min,Y_max,r1=sphere_radius+z_offset-leaflet_z,r2=sphere_radius+z_offset,c=-sphere_radius)-memvol[bilayer][0]
            elif args.xygauss:
                lipid_vol_up           = gauss_integral_square(X_min,X_max,Y_min,Y_max,*map(float,args.xygauss),g1=z_offset,g2=z_offset+leaflet_z)-memvol[bilayer][1]
                lipid_vol_down         = gauss_integral_square(X_min,X_max,Y_min,Y_max,*map(float,args.xygauss),g1=z_offset-leaflet_z,g2=z_offset)-memvol[bilayer][0]
            else:
                lipid_vol_up           = ((X_len+2*lip_offset)*(Y_len+2*lip_offset)*leaflet_z)-memvol[bilayer][1]
                lipid_vol_down         = ((X_len+2*lip_offset)*(Y_len+2*lip_offset)*leaflet_z)-memvol[bilayer][0]
            lipid_vol              = (lipid_vol_down,lipid_vol_up)
            lipid_area             = X_len*Y_len # if curvature, will be defined in loop
            if args.xygauss:
               lipid_area          = gauss_rectangle_area(X_min,X_max,Y_min,Y_max, *map(float,args.xygauss))
            pond_lip_vol_dict[bilayer]      = {}
            pond_lip_apl_dict[bilayer]      = {}
            lipnum_dict[bilayer]            = {}
            lipnum_area_dict[bilayer]       = {}
            for leaflet in composition[bilayer]:
                if args.curvature is not None:
                    if leaflet < 1:
                        #lipid_area    = sphere_rectangle_area(sphere_radius+z_offset-leaflet_z,sphere_dist(sphere_radius,X_len),sphere_dist(sphere_radius,Y_len))
                        lipid_area    = sphere_rectangle_area(sphere_radius+z_offset-leaflet_z,X_len,Y_len)
                        logger.debug("Curvature lower leaflet area:"+str(lipid_area))
                    else:
                        #lipid_area    = sphere_rectangle_area(sphere_radius+z_offset+leaflet_z,sphere_dist(sphere_radius,X_len),sphere_dist(sphere_radius,Y_len))
                        lipid_area    = sphere_rectangle_area(sphere_radius+z_offset+leaflet_z,X_len,Y_len)
                        logger.debug("Curvature upper leaflet area:"+str(lipid_area))
                pond_lip_vol = 0
                pond_lip_apl = 0
                for lipid in composition[bilayer][leaflet]:
                    if parameters[lipid]["V"] == "XXXX":
                        if parameters[lipid]["C"] == "X":
                            logger.critical("CRITICAL:\n  Volume not specified and can not be estimated! Check the parameter file")
                            exit()
                        nCH3,nCH2,nCH = list(map(int,parameters[lipid]["C"].split(":")))
                        parameters[lipid]["V"] = str(int(round(float(parameters[lipid]["VH"])+nCH3*2*VCH2+nCH2*VCH2+nCH*VCH)))         #doi:10.1016/j.bbamem.2005.07.006
                        logger.debug("Experimental value for "+lipid+" volume not available in parm file. Using estimated "+parameters[lipid]["V"]+" A^3 instead...")
                    if parameters[lipid][apl] == "XX":
#                        parameters[lipid]["APL"] = "75"
                        try:
                            parameters[lipid][apl] = max([float(parameters[lip][apl]) for lip in parameters if (is_number(parameters[lip][apl]) and lip.endswith(lipid[-2:]))])
                            logger.debug("Taking maximal APL of lipids with headgroup "+lipid[-2:])
                        except:
                            parameters[lipid][apl] = "75"
                            logger.debug("No other lipid with same headgroup has APL. Setting APL of 75 to "+lipid[-2:])
                        logger.debug("Value for "+lipid+" area per lipid not available in parm file. Using "+str(parameters[lipid][apl])+" A^2 instead...")
                    pond_lip_vol += composition[bilayer][leaflet][lipid]*int(parameters[lipid]["V"])
                    pond_lip_apl += composition[bilayer][leaflet][lipid]*int(parameters[lipid][apl])
                pond_lip_apl = pond_lip_apl*apl_offset[bilayer][leaflet]
                lipnum = lipid_vol[leaflet]/pond_lip_vol
                lipnum_area = lipid_area/pond_lip_apl-(memvol[bilayer][leaflet]/pond_lip_vol)
                pond_lip_vol_dict[bilayer][leaflet]      = pond_lip_vol
                pond_lip_apl_dict[bilayer][leaflet]      = pond_lip_apl
                lipnum_dict[bilayer][leaflet]            = lipnum
                lipnum_area_dict[bilayer][leaflet]       = lipnum_area

            charge_lip = charge_solute = 0
            if not args.vol:
                lipnum_dict = lipnum_area_dict

            ################################ SOLUTE ######################################

            if not args.solvate:
                if args.solute is not None and args.solute_inmem:
                    for i,sol in enumerate(args.solute):
                            logger.info("Adding "+args.solute_con[i]+" "+args.solute[i]+" to the lipid volume")
                            grid_file, solute_vol      = pdbvol(args.solute[i])
                            created.append(grid_file)
                            if args.solute_con[i].endswith("M") and is_number(args.solute_con[i][:-1]):
                                solute_num      = int(float(args.solute_con[i][:-1])*((sum(lipid_vol)*avogadro/(1*10**27))))
                            elif args.solute_con[i].endswith("%") and is_number(args.solute_con[i][:-1]):
                                solute_num      = int(float(args.solute_con[i][:-1])/100*((sum(lipid_vol)/solute_vol)))
                                solute_vol_tot  = int(float(args.solute_con[i][:-1])/100*(sum(lipid_vol)))
                            elif is_number(args.solute_con[i]):
                                try:
                                    int(args.solute_con[i])
                                except:
                                    logger.error("ERROR:\n    A number less than 1 is specified. If a concentration was intended, add M/% as a suffix!")
                                    exit()
                                solute_num      = int(args.solute_con[i])
                            else:
                                logger.error("ERROR:\n    The format used to specify the number of molecules is not correct! It has to be a number or a number with an M/% suffix.")
                                exit()
                            if solute_num < 1:
                                logger.error("ERROR:\n    The solute concentration is too low for the calculated box size. Try increasing the concentration.")
                                exit()
                            if not args.solute_con[i].endswith("%"):
                                solute_vol_tot  = solute_vol*solute_num
                            charge_solute += args.solute_charge[i]*solute_num
                            for leaflet in lipnum_dict[bilayer]:
                                lipnum_dict[bilayer][leaflet] -= int((solute_vol_tot)/(2*pond_lip_vol_dict[bilayer][leaflet]))

                            content_solute += "structure "+args.solute[i]+"\n"
                            content_solute += "  number "+str(int(solute_num))+"\n"
                            if args.solute_prot_dist is not None and args.pdb[bilayer] != "None":
                                content_solute += "  outside cylinder 0. 0. "+str(minmax[2]-args.solute_prot_dist)+" 0. 0. 1. "+str(max_rad+args.solute_prot_dist)+" "+str(minmax[5]-minmax[2]+args.solute_prot_dist)+" \n"
                            if args.curvature is not None:
                                content_solute += "  inside sphere 0. 0. "+str(-sphere_radius)+" "+str(z_offset+sphere_radius+leaflet_z)+"\n"
                                content_solute += "  outside sphere 0. 0. "+str(-sphere_radius)+" "+str(z_offset+sphere_radius-leaflet_z)+"\n"
                            elif args.xygauss:
                                content_solute += "  below xygauss 0. 0. "+args.xygauss[0]+" "+args.xygauss[1]+" "+str(z_offset+leaflet_z)+" "+args.xygauss[2]+"\n"
                                content_solute += "  over xygauss 0. 0. "+args.xygauss[0]+" "+args.xygauss[1]+" "+str(z_offset-leaflet_z)+" "+args.xygauss[2]+"\n"
                            else:
                                content_solute += "  inside box "+str(round(X_min*lip_offset,2))+" "+str(round(Y_min*lip_offset,2))+" "+str(z_offset-leaflet_z)+" "+str(round(X_max*lip_offset,2))+" "+str(round(Y_max*lip_offset,2))+" "+str(z_offset+leaflet_z)+"\n"
                            content_solute += "end structure\n\n"
                elif (args.solute is not None or args.solute_con is not None) and args.solute_inmem:
                    logger.error("ERROR:\n    The solute parameters are incomplete. Please include both a solute pdb and a concentration.")
                    exit()


            if not args.solvate:
                for leaflet in composition[bilayer]:
                    for lipid in sorted(composition[bilayer][leaflet], reverse=True, key=lambda x: composition[bilayer][leaflet][x]):
                        if args.headplane is None:
                            bound_head=float(parameters[lipid]["h_bound"])
                            if bound_head >= leaflet_z:
                                logger.error("ERROR:\n    The boundary for "+lipid+" head group is out of the space delimited for the membrane by the membrane width "+leaflet_z+". Please consider increasing the value!")
                                exit()
                        if args.tailplane is None:
                            bound_tail=float(parameters[lipid]["t_bound"])
                            if bound_tail <=0:
                                logger.error("ERROR:\n    The boundary for "+lipid+" tail is out of the space delimited for the membrane by the membrane center at the z axis origin (it must be a positive value greater than 0). Please consider increasing the value!")
                                exit()
                        if not os.path.isfile("./"+lipid+".pdb"):
                            try:
                                shutil.copy(script_path+rep+"/pdbs/"+lipid+".pdb", "./")
                            except:
                                pdbtar.extract(lipid+".pdb")
                            created_notrun.append(lipid+".pdb")

                        content_lipid += "structure "+lipid+".pdb\n"
                        sp = 0 
                        if lipid in sterols: ## Avoid ring piercing by lipid tails, as discussed with Slochower. TODO: Extend to more sterols? -> Test!
                            content_lipid += "  radius 1.5\n"
                            if sum([composition[bilayer][leaflet][l] for l in composition[bilayer][leaflet] if l in sterols]) < 0.5 and (X_len > 50 and Y_len > 50): # only enable if less then half of the composition of the leaflet are sterols
                                logger.info("Adding 5A padding to the sterol %s components to avoid piercing in the periodic boundary" % (lipid))
                                sp = 5 #Safety padding to avoid having sterols in the system rim and piercing from periodic image. Taking about "a lipid" width
                            else:
                                logger.warning("Sterols are used, and the concentration is too high or the system too small to add proper side padding. Check that your system doesn't have pierced sterols in the periodic boundary once the packing is finished")
                        content_lipid += "  nloop "+str(nloop)+"\n"
                        if int(round(composition[bilayer][leaflet][lipid]*lipnum_dict[bilayer][leaflet])) < 1:
                            logger.error("ERROR:\n    The ratio for lipid "+lipid+" is too small for the given/estimated system size. Either increase the ratio or make the system bigger!")
                            exit()
                        content_lipid += "  number "+str(int(round(composition[bilayer][leaflet][lipid]*lipnum_dict[bilayer][leaflet])))+"\n"

                        if args.curvature is not None or args.xygauss or args.self_assembly:
                            content_lipid += "  inside box "+str(round(X_min*lip_offset,2)+sp)+" "+str(round(Y_min*lip_offset,2)+sp)+" "+str(Z_dim[bilayer][0]+z_offset)+" "+str(round(X_max*lip_offset,2)-sp)+" "+str(round(Y_max*lip_offset,2)-sp)+" "+str(Z_dim[bilayer][1]+z_offset)+"\n"
                        else:
                            content_lipid += "  inside box "+str(round(X_min*lip_offset,2)+sp)+" "+str(round(Y_min*lip_offset,2)+sp)+" "+str(z_offset-leaflet_z+leaflet_z*leaflet)+" "+str(round(X_max*lip_offset,2)-sp)+" "+str(round(Y_max*lip_offset,2)-sp)+" "+str(z_offset+leaflet_z*leaflet)+"\n"

                        if args.channel_plug is not None and args.pdb[bilayer] != "None":
                            if args.channel_plug == 0:
                                args.channel_plug = max_rad/2
                            content_lipid += "  outside cylinder 0. 0. "+str(minmax[2])+" 0. 0. 1. "+str(args.channel_plug)+" "+str(minmax[5]-minmax[2])+" \n"

                        if not args.self_assembly:
                            content_lipid += "  atoms "+" ".join([p_atm for p_atm in parameters[lipid]["p_atm"].split(",")])+"\n"
                            if leaflet == 0:
                                if args.curvature is not None:
                                    content_lipid += "    inside sphere 0. 0. "+str(-sphere_radius)+" "+str(sphere_radius-bound_head+z_offset)+"\n"
                                elif args.xygauss:
                                    content_lipid += "    below xygauss 0. 0. "+args.xygauss[0]+" "+args.xygauss[1]+" "+str(-bound_head+z_offset)+" "+args.xygauss[2]+"\n"
                                else:
                                    content_lipid += "    below plane 0. 0. 1. "+str(-bound_head+z_offset)+"\n"
                            else:
                                if args.curvature is not None:
                                    content_lipid += "    outside sphere 0. 0. "+str(-sphere_radius)+" "+str(sphere_radius+bound_head+z_offset)+"\n"
                                elif args.xygauss:
                                    content_lipid += "    over xygauss 0. 0. "+args.xygauss[0]+" "+args.xygauss[1]+" "+str(bound_head+z_offset)+" "+args.xygauss[2]+"\n"
                                else:
                                    content_lipid += "    over plane 0. 0. 1. "+str(bound_head+z_offset)+"\n"
                            content_lipid += "  end atoms\n"
                            content_lipid += "  atoms "+" ".join([t_atm for t_atm in parameters[lipid]["t_atm"].split(",")])+"\n"
                            if leaflet == 0:
                                if args.curvature is not None:
                                    content_lipid += "    outside sphere 0. 0. "+str(-sphere_radius)+" "+str(sphere_radius-bound_tail+z_offset)+"\n"
                                elif args.xygauss:
                                    content_lipid += "    over xygauss 0. 0. "+args.xygauss[0]+" "+args.xygauss[1]+" "+str(-bound_tail+z_offset)+" "+args.xygauss[2]+"\n"
                                else:
                                    content_lipid += "    over plane 0. 0. 1. "+str(-bound_tail+z_offset)+"\n"
                            else:
                                if args.curvature is not None:
                                    content_lipid += "    inside sphere 0. 0. "+str(-sphere_radius)+" "+str(sphere_radius+bound_tail+z_offset)+"\n"
                                elif args.xygauss:
                                    content_lipid += "    below xygauss 0. 0. "+args.xygauss[0]+" "+args.xygauss[1]+" "+str(bound_tail+z_offset)+" "+args.xygauss[2]+"\n"
                                else:
                                    content_lipid += "    below plane 0. 0. 1. "+str(bound_tail+z_offset)+"\n"
                            content_lipid += "  end atoms\n"
                        content_lipid += "end structure\n\n"

            ######################## WATER && SOLUTE #####################################

            for solvent in args.solvents.split(":"):
                solvent_pdb = solvent+".pdb"
                if os.path.isfile(solvent_pdb):
                    logger.info("Using "+solvent_pdb+" in the folder")
                else:
                    try:
                        shutil.copy(os.path.join(script_path, rep, "pdbs", solvent_pdb), "./")
                    except:
                        pdbtar.extract(solvent_pdb)
                    created_notrun.append(solvent_pdb)
                if not os.path.isfile(solvent_pdb):
                    logger.critical("CRITICAL:"+solvent_pdb+" is not to found in the folder!")
                    exit()

#            print(n,bilayer,Z_dim,solvol)

            if args.curvature is not None:
                solvent_vol_up           = sphere_integral_square(X_min,X_max,Y_min,Y_max,r1=sphere_radius+z_offset+leaflet_z,z_max=Z_dim[bilayer][1]+z_offset,c=-sphere_radius)-solvol[bilayer][1]
                solvent_vol_down         = sphere_integral_square(X_min,X_max,Y_min,Y_max,z_min=Z_dim[bilayer][0]+z_offset,r2=sphere_radius+z_offset-leaflet_z,c=-sphere_radius)-solvol[bilayer][0]
            elif args.xygauss:
                solvent_vol_up           = gauss_integral_square(X_min,X_max,Y_min,Y_max,*map(float,args.xygauss),g1=z_offset+leaflet_z,z_max=Z_dim[bilayer][1]+z_offset)-solvol[bilayer][1]
                solvent_vol_down         = gauss_integral_square(X_min,X_max,Y_min,Y_max,*map(float,args.xygauss),z_min=Z_dim[bilayer][0]+z_offset,g2=z_offset-leaflet_z)-solvol[bilayer][0]
            else:
                solvent_vol_up   = (X_len*Y_len*(abs(Z_dim[bilayer][1])-leaflet_z))-solvol[bilayer][1]
                solvent_vol_down = (X_len*Y_len*(abs(Z_dim[bilayer][0])-leaflet_z))-solvol[bilayer][0]
            if args.solvate:
                solvent_vol_up   = solvent_vol_up+lipid_vol_up
                solvent_vol_down = solvent_vol_down+lipid_vol_down
            solvent_vol_tot = solvent_vol_up+solvent_vol_down
            watnum_up = int(solvent_vol_up*solvent_con)
            watnum_down = int(solvent_vol_down*solvent_con)

            if args.solute is not None and not args.solute_inmem:
                for i,sol in enumerate(args.solute):
                    logger.info("Adding "+args.solute_con[i]+" "+args.solute[i]+" to the water volume")
                    grid_file, solute_vol      = pdbvol(args.solute[i])
                    created.append(grid_file)
                    if args.solute_con[i].endswith("M") and is_number(args.solute_con[i][:-1]):
                        solute_up       = int(float(args.solute_con[i][:-1])*((solvent_vol_up*avogadro/(1*10**27))))
                        solute_down     = int(float(args.solute_con[i][:-1])*((solvent_vol_down*avogadro/(1*10**27))))
                    elif args.solute_con[i].endswith("%") and is_number(args.solute_con[i][:-1]):
                        solute_up       = int(float(args.solute_con[i][:-1])/100*((solvent_vol_up/solute_vol)))
                        solute_down     = int(float(args.solute_con[i][:-1])/100*((solvent_vol_down/solute_vol)))
                        solute_vol_up   = int(float(args.solute_con[i][:-1])/100*(solvent_vol_up))
                        solute_vol_down = int(float(args.solute_con[i][:-1])/100*(solvent_vol_down))
                    elif is_number(args.solute_con[i]):
                        try:
                            int(args.solute_con[i])
                        except:
                            logger.error("ERROR:\n    A number less than 1 is specified. If a concentration was intended, add M as a suffix!")
                            exit()
                        solute_up, solute_down = distribute_integer(int(args.solute_con[i]),[solvent_vol_up,solvent_vol_down])
                    else:
                        logger.error("ERROR:\n    The format used to specify the number of molecules is not correct! It has to be a number or a number with an M/% suffix.")
                        exit()
                    if not args.solute_con[i].endswith("%"):
                        solute_vol_up   = solute_vol*solute_up
                        solute_vol_down = solute_vol*solute_down
                    watnum_up       = watnum_up-int((solute_vol_up)*solvent_con)
                    watnum_down     = watnum_down-int((solute_vol_down)*solvent_con)
                    if solute_up+solute_down < 1:
                        logger.error("ERROR:\n    The solute concentration is too low for the calculated box size. Try increasing the concentration.")
                        exit()
                    charge_solute += args.solute_charge[i]*(solute_down+solute_up)
                    if not args.solvate and not args.self_assembly:
                        if solute_down > 0:
                            content_solute += "structure "+args.solute[i]+"\n"
                            content_solute += "  nloop "+str(nloop)+"\n"
                            content_solute += "  number "+str(solute_down)+"\n"
                            if args.solute_prot_dist is not None and args.pdb[bilayer] != "None":
                                content_solute += "  outside cylinder 0. 0. "+str(minmax[2]-args.solute_prot_dist)+" 0. 0. 1. "+str(max_rad+args.solute_prot_dist)+" "+str(minmax[5]-minmax[2]+args.solute_prot_dist)+" \n"
                            if args.curvature is not None:
                                content_solute += "  inside box "+str(round(X_min,2))+" "+str(round(Y_min,2))+" "+str(round(Z_dim[bilayer][0]+z_offset,2))+" "+str(round(X_max,2))+" "+str(round(Y_max,2))+" "+str(Z_dim[bilayer][1])+"\n"
                                content_solute += "  inside sphere 0. 0. "+str(-sphere_radius)+" "+str(sphere_radius-leaflet_z+z_offset)+"\n"
                            elif args.xygauss:
                                content_solute += "  inside box "+str(round(X_min,2))+" "+str(round(Y_min,2))+" "+str(round(Z_dim[bilayer][0]+z_offset,2))+" "+str(round(X_max,2))+" "+str(round(Y_max,2))+" "+str(Z_dim[bilayer][1])+"\n"
                                content_solute += "  below xygauss 0. 0. "+args.xygauss[0]+" "+args.xygauss[1]+" "+str(-leaflet_z+z_offset)+" "+args.xygauss[2]+"\n"
                            else:
                                content_solute += "  inside box "+str(round(X_min,2))+" "+str(round(Y_min,2))+" "+str(round(Z_dim[bilayer][0]+z_offset,2))+" "+str(round(X_max,2))+" "+str(round(Y_max,2))+" "+str(-leaflet_z+z_offset)+"\n"
                            content_solute += "end structure\n\n"
                        if solute_up > 0:
                            content_solute += "structure "+args.solute[i]+"\n"
                            content_solute += "  nloop "+str(nloop)+"\n"
                            content_solute += "  number "+str(solute_up)+"\n"
                            if args.solute_prot_dist is not None and args.pdb[bilayer] != "None":
                                content_solute += "  outside cylinder 0. 0. "+str(minmax[2]-args.solute_prot_dist)+" 0. 0. 1. "+str(max_rad+args.solute_prot_dist)+" "+str(minmax[5]-minmax[2]+args.solute_prot_dist)+" \n"
                            if args.curvature is not None:
                                content_solute += "  inside box "+str(round(X_min,2))+" "+str(round(Y_min,2))+" "+str(round(Z_dim[bilayer][0]+z_offset,2))+" "+str(round(X_max,2))+" "+str(round(Y_max,2))+" "+str(Z_dim[bilayer][1])+"\n"
                                content_solute += "  outside sphere 0. 0. "+str(-sphere_radius)+" "+str(sphere_radius+leaflet_z+z_offset)+"\n"
                            elif args.xygauss:
                                content_solute += "  inside box "+str(round(X_min,2))+" "+str(round(Y_min,2))+" "+str(round(Z_dim[bilayer][0]+z_offset,2))+" "+str(round(X_max,2))+" "+str(round(Y_max,2))+" "+str(Z_dim[bilayer][1])+"\n"
                                content_solute += "  below xygauss 0. 0. "+args.xygauss[0]+" "+args.xygauss[1]+" "+str(leaflet_z+z_offset)+" "+args.xygauss[2]+"\n"
                            else:
                                content_solute += "  inside box "+str(round(X_min,2))+" "+str(round(Y_min,2))+" "+str(leaflet_z+z_offset)+" "+str(round(X_max,2))+" "+str(round(Y_max,2))+" "+str(round(Z_dim[bilayer][1]+z_offset,2))+"\n"
                            content_solute += "end structure\n\n"
                    else:
                        content_solute += "structure "+args.solute[i]+"\n"
                        content_solute += "  nloop "+str(nloop)+"\n"
                        content_solute += "  number "+str(solute_down+solute_up)+"\n"
                        if args.solute_prot_dist is not None and args.pdb[bilayer] != "None":
                                content_solute += "  outside cylinder 0. 0. "+str(minmax[2]-args.solute_prot_dist)+" 0. 0. 1. "+str(max_rad+args.solute_prot_dist)+" "+str(minmax[5]-minmax[2]+args.solute_prot_dist)+" \n"
                        content_solute += "  inside box "+str(round(X_min,2))+" "+str(round(Y_min,2))+" "+str(round(Z_dim[bilayer][0]+z_offset,2))+" "+str(round(X_max,2))+" "+str(round(Y_max,2))+" "+str(round(Z_dim[bilayer][1]+z_offset,2))+"\n"
                        content_solute += "end structure\n\n"

            elif (args.solute is not None or args.solute_con is not None) and not args.solute_inmem:
                logger.error("ERROR:\n    The solute parameters are incomplete. Please include both a solute pdb and a concentration.")
                exit()

            ################################# SALT & CHARGES #############################

            pos_up = pos_down = 0
            neg_up = neg_down = 0
            charge = charges[bilayer]
            if not args.solvate:
                for leaflet in composition[bilayer]:
                    for lipid in composition[bilayer][leaflet]:
                        charge_lip += int(round(composition[bilayer][leaflet][lipid]*lipnum_dict[bilayer][leaflet]))*int(parameters[lipid]["charge"])
            if charge_lip != 0:
                logger.debug("The lipids contribute a charge of "+str(charge_lip)+" to the system. It will be considered for the neutralization.")
                charge += charge_lip
            if charge_solute != 0:
                logger.debug("The solutes contribute a charge of "+str(charge_solute)+" to the system. It will be considered for the neutralization.")
                charge += charge_solute
            if charge > 0:
                neg_up = int(round(charge*(solvent_vol_up/(solvent_vol_tot))))
                neg_down = int(round(charge*(solvent_vol_down/(solvent_vol_tot))))
            else:
                pos_up = int(round((abs(charge)/ion_dict[args.salt_c][1])*(solvent_vol_up/(solvent_vol_tot))))
                pos_down = int(round((abs(charge)/ion_dict[args.salt_c][1])*(solvent_vol_down/(solvent_vol_tot))))
            con_pos = (pos_up+pos_down)/((solvent_vol_tot)*avogadro/(1*10**27))
            con_neg = (neg_up+neg_down)/((solvent_vol_tot)*avogadro/(1*10**27))
            if args.salt:
                if con_pos > saltcon or con_neg > saltcon*ion_dict[args.salt_c][1]:
            #        print pos_up, pos_down, neg_up, neg_down, saltnum_up, saltnum_down
                    logger.warning("""WARNING:
            The concentration of ions required to neutralize the system is higher than the concentration specified.
            Either increase the salt concentration by using the --saltcon flag or run the script without the --salt flag.""")
                    logger.info("Positive ion concentration: "+str(round(con_pos,3)))
                    logger.info("Negative ion concentration: "+str(round(con_neg,3)))
                    logger.info("Salt concentration specified: "+str(saltcon))
                    if override_salt:
                        if args.verbose:
                            logger.info("Overriding salt concentration...")
                        saltcon = max(con_pos,con_neg)
                        pass
                    else:
                        exit()
                saltnum_up   = int(solvent_vol_up*saltcon*avogadro/(1*10**27))
                saltnum_down = int(solvent_vol_down*saltcon*avogadro/(1*10**27))

                if abs(charge)/2 < min(saltnum_up,saltnum_down):
                    pos_up   += saltnum_up-abs(charge)/(ion_dict[args.salt_c][1]*2)
                    pos_down += saltnum_down-abs(charge)/(ion_dict[args.salt_c][1]*2)
                    neg_up   += saltnum_up*ion_dict[args.salt_c][1]-abs(charge)/2
                    neg_down += saltnum_down*ion_dict[args.salt_c][1]-abs(charge)/2

                if args.charge_imbalance != 0:
                    if n % 2 == 0:
                        if args.imbalance_ion == "cat":
                            pos_up   += args.charge_imbalance/ion_dict[args.salt_c][1]
                            pos_down -= args.charge_imbalance/ion_dict[args.salt_c][1]
                        else:
                            neg_up   -= args.charge_imbalance
                            neg_down += args.charge_imbalance
                    else:
                        if args.imbalance_ion == "cat":
                            pos_up   -= args.charge_imbalance/ion_dict[args.salt_c][1]
                            pos_down += args.charge_imbalance/ion_dict[args.salt_c][1]
                        else:
                            neg_up   += args.charge_imbalance
                            neg_down -= args.charge_imbalance

                charge_data= """
Salt and charge info:
Upper positive charges   = %-9s
Lower positive charges   = %-9s
Upper negative charges   = %-9s
Lower negative charges   = %-9s
Charge imbalance         = %-9s
Upper salt number        = %-9s
Lower salt number        = %-9s
            """
                logger.debug(charge_data % ( pos_up, pos_down, neg_up, neg_down, args.charge_imbalance, saltnum_up, saltnum_down ))

                checkup = [pos_up,pos_down,neg_up,neg_down]
                if any(v < 0 for v in checkup):
                    logger.critical("CRITICAL:\n  The applied charge imbalance caused a negative number of ions! Check your input")
                    exit()


            #    new_con_neg = (neg_up+neg_down)/(((solvent_vol_tot)*avogadro/(1*10**27)))
            #    new_con_pos = (pos_up+pos_down)/(((solvent_vol_tot)*avogadro/(1*10**27)))

            try:
                shutil.copy(os.path.join(script_path, rep, "pdbs", cation+".pdb"), "./")
            except:
                pdbtar.extract(cation+".pdb")
            created_notrun.append(cation+".pdb")
            try:
                shutil.copy(os.path.join(script_path, rep, "pdbs", anion+".pdb"), "./")
            except:
                pdbtar.extract(anion+".pdb")
            created_notrun.append(anion+".pdb")
            if not args.solvate and not args.self_assembly:
                if pos_down > 0:
                    content_ion += "structure "+cation+".pdb\n"
                    content_ion += "  nloop "+str(nloop)+"\n"
                    content_ion += "  number "+str(int(pos_down))+"\n"
                    if args.curvature is not None:
                        content_ion += "  inside box "+str(round(X_min,2))+" "+str(round(Y_min,2))+" "+str(round(Z_dim[bilayer][0]+z_offset,2))+" "+str(round(X_max,2))+" "+str(round(Y_max,2))+" "+str(Z_dim[bilayer][1])+"\n"
                        content_ion += "  inside sphere 0. 0. "+str(-sphere_radius)+" "+str(sphere_radius-leaflet_z+z_offset)+"\n"
                    elif args.xygauss:
                        content_ion += "  inside box "+str(round(X_min,2))+" "+str(round(Y_min,2))+" "+str(round(Z_dim[bilayer][0]+z_offset,2))+" "+str(round(X_max,2))+" "+str(round(Y_max,2))+" "+str(Z_dim[bilayer][1])+"\n"
                        content_ion += "  below xygauss 0. 0. "+args.xygauss[0]+" "+args.xygauss[1]+" "+str(-leaflet_z+z_offset)+" "+args.xygauss[2]+"\n"
                    else:
                        content_ion += "  inside box "+str(round(X_min,2))+" "+str(round(Y_min,2))+" "+str(round(Z_dim[bilayer][0]+z_offset,2))+" "+str(round(X_max,2))+" "+str(round(Y_max,2))+" "+str(-leaflet_z+z_offset)+"\n"
                    content_ion += "end structure\n\n"
                if pos_up > 0:
                    content_ion += "structure "+cation+".pdb\n"
                    content_ion += "  nloop "+str(nloop)+"\n"
                    content_ion += "  number "+str(int(pos_up))+"\n"
                    if args.curvature is not None:
                        content_ion += "  inside box "+str(round(X_min,2))+" "+str(round(Y_min,2))+" "+str(round(Z_dim[bilayer][0]+z_offset,2))+" "+str(round(X_max,2))+" "+str(round(Y_max,2))+" "+str(Z_dim[bilayer][1])+"\n"
                        content_ion += "  outside sphere 0. 0. "+str(-sphere_radius)+" "+str(sphere_radius+leaflet_z+z_offset)+"\n"
                    elif args.xygauss:
                        content_ion += "  inside box "+str(round(X_min,2))+" "+str(round(Y_min,2))+" "+str(round(Z_dim[bilayer][0]+z_offset,2))+" "+str(round(X_max,2))+" "+str(round(Y_max,2))+" "+str(Z_dim[bilayer][1])+"\n"
                        content_ion += "  over xygauss 0. 0. "+args.xygauss[0]+" "+args.xygauss[1]+" "+str(leaflet_z+z_offset)+" "+args.xygauss[2]+"\n"
                    else:
                        content_ion += "  inside box "+str(round(X_min,2))+" "+str(round(Y_min,2))+" "+str(leaflet_z+z_offset)+" "+str(round(X_max,2))+" "+str(round(Y_max,2))+" "+str(round(Z_dim[bilayer][1]+z_offset,2))+"\n"
                    content_ion += "end structure\n\n"
                if neg_down > 0:
                    content_ion += "structure "+anion+".pdb\n"
                    content_ion += "  nloop "+str(nloop)+"\n"
                    content_ion += "  number "+str(int(neg_down))+"\n"
                    if args.curvature is not None:
                        content_ion += "  inside box "+str(round(X_min,2))+" "+str(round(Y_min,2))+" "+str(round(Z_dim[bilayer][0]+z_offset,2))+" "+str(round(X_max,2))+" "+str(round(Y_max,2))+" "+str(Z_dim[bilayer][1])+"\n"
                        content_ion += "  inside sphere 0. 0. "+str(-sphere_radius)+" "+str(sphere_radius-leaflet_z+z_offset)+"\n"
                    elif args.xygauss:
                        content_ion += "  inside box "+str(round(X_min,2))+" "+str(round(Y_min,2))+" "+str(round(Z_dim[bilayer][0]+z_offset,2))+" "+str(round(X_max,2))+" "+str(round(Y_max,2))+" "+str(Z_dim[bilayer][1])+"\n"
                        content_ion += "  below xygauss 0. 0. "+args.xygauss[0]+" "+args.xygauss[1]+" "+str(-leaflet_z+z_offset)+" "+args.xygauss[2]+"\n"
                    else:
                        content_ion += "  inside box "+str(round(X_min,2))+" "+str(round(Y_min,2))+" "+str(round(Z_dim[bilayer][0]+z_offset,2))+" "+str(round(X_max,2))+" "+str(round(Y_max,2))+" "+str(-leaflet_z+z_offset)+"\n"
                    content_ion += "end structure\n\n"
                if neg_up > 0:
                    content_ion += "structure "+anion+".pdb\n"
                    content_ion += "  nloop "+str(nloop)+"\n"
                    content_ion += "  number "+str(int(neg_up))+"\n"
                    if args.curvature is not None:
                        content_ion += "  inside box "+str(round(X_min,2))+" "+str(round(Y_min,2))+" "+str(round(Z_dim[bilayer][0]+z_offset,2))+" "+str(round(X_max,2))+" "+str(round(Y_max,2))+" "+str(Z_dim[bilayer][1])+"\n"
                        content_ion += "  outside sphere 0. 0. "+str(-sphere_radius)+" "+str(sphere_radius+leaflet_z+z_offset)+"\n"
                    elif args.xygauss:
                        content_ion += "  inside box "+str(round(X_min,2))+" "+str(round(Y_min,2))+" "+str(round(Z_dim[bilayer][0]+z_offset,2))+" "+str(round(X_max,2))+" "+str(round(Y_max,2))+" "+str(Z_dim[bilayer][1])+"\n"
                        content_ion += "  over xygauss 0. 0. "+args.xygauss[0]+" "+args.xygauss[1]+" "+str(leaflet_z+z_offset)+" "+args.xygauss[2]+"\n"
                    else:
                        content_ion += "  inside box "+str(round(X_min,2))+" "+str(round(Y_min,2))+" "+str(leaflet_z+z_offset)+" "+str(round(X_max,2))+" "+str(round(Y_max,2))+" "+str(round(Z_dim[bilayer][1]+z_offset,2))+"\n"
                    content_ion += "end structure\n\n"
            else:
                if pos_down+pos_up > 0:
                    content_ion += "structure "+cation+".pdb\n"
                    content_ion += "  nloop "+str(nloop)+"\n"
                    content_ion += "  number "+str(int(pos_down+pos_up))+"\n"
                    content_ion += "  inside box "+str(round(X_min,2))+" "+str(round(Y_min,2))+" "+str(round(Z_dim[bilayer][0]+z_offset,2))+" "+str(round(X_max,2))+" "+str(round(Y_max,2))+" "+str(round(Z_dim[bilayer][1]+z_offset,2))+"\n"
                    content_ion += "end structure\n\n"
                if neg_down+neg_up > 0:
                    content_ion += "structure "+anion+".pdb\n"
                    content_ion += "  nloop "+str(nloop)+"\n"
                    content_ion += "  number "+str(int(neg_down+neg_up))+"\n"
                    content_ion += "  inside box "+str(round(X_min,2))+" "+str(round(Y_min,2))+" "+str(round(Z_dim[bilayer][0]+z_offset,2))+" "+str(round(X_max,2))+" "+str(round(Y_max,2))+" "+str(round(Z_dim[bilayer][1]+z_offset,2))+"\n"
                    content_ion += "end structure\n\n"

            for i, solvent in enumerate(args.solvents.split(":")):
                solvent_pdb   = solvent+".pdb"
                solvents_up   = int((watnum_up/solvent_con)*(solvent_ratios[i]/float(sum(solvent_ratios)))*(avogadro/(1*10**24))*(float(sparameters[solvent]["density"])/float(sparameters[solvent]["MW"])))
                solvents_down = int((watnum_down/solvent_con)*(solvent_ratios[i]/float(sum(solvent_ratios)))*(avogadro/(1*10**24))*(float(sparameters[solvent]["density"])/float(sparameters[solvent]["MW"])))
                if not args.solvate and not args.self_assembly:
                    if solvents_down > 0:
                        content_solvent += "structure "+solvent_pdb+"\n"
                        content_solvent += "  nloop "+str(nloop)+"\n"
                        content_solvent += "  number "+str(solvents_down)+"\n" # deleted -pos_down-neg_down. Was it necessary?
                        if args.curvature is not None:
                            content_solvent += "  inside box "+str(round(X_min,2))+" "+str(round(Y_min,2))+" "+str(round(Z_dim[bilayer][0]+z_offset,2))+" "+str(round(X_max,2))+" "+str(round(Y_max,2))+" "+str(Z_dim[bilayer][1])+"\n"
                            content_solvent += "  inside sphere 0. 0. "+str(-sphere_radius)+" "+str(sphere_radius-leaflet_z+z_offset)+"\n"
                        elif args.xygauss:
                            content_solvent += "  inside box "+str(round(X_min,2))+" "+str(round(Y_min,2))+" "+str(round(Z_dim[bilayer][0]+z_offset,2))+" "+str(round(X_max,2))+" "+str(round(Y_max,2))+" "+str(Z_dim[bilayer][1])+"\n"
                            content_solvent += "  below xygauss 0. 0. "+args.xygauss[0]+" "+args.xygauss[1]+" "+str(-leaflet_z+z_offset)+" "+args.xygauss[2]+"\n"
                        else:
                            content_solvent += "  inside box "+str(round(X_min,2))+" "+str(round(Y_min,2))+" "+str(round(Z_dim[bilayer][0]+z_offset,2))+" "+str(round(X_max,2))+" "+str(round(Y_max,2))+" "+str(-leaflet_z+z_offset)+"\n"
                        content_solvent += "end structure\n\n"
                    if solvents_up > 0:
                        content_solvent += "structure "+solvent_pdb+"\n"
                        content_solvent += "  nloop "+str(nloop)+"\n"
                        content_solvent += "  number "+str(solvents_up)+"\n" # deleted -pos_up-neg_up. Was it necessary?
                        if args.curvature is not None:
                            content_solvent += "  inside box "+str(round(X_min,2))+" "+str(round(Y_min,2))+" "+str(round(Z_dim[bilayer][0]+z_offset,2))+" "+str(round(X_max,2))+" "+str(round(Y_max,2))+" "+str(Z_dim[bilayer][1])+"\n"
                            content_solvent += "  outside sphere 0. 0. "+str(-sphere_radius)+" "+str(sphere_radius+leaflet_z+z_offset)+"\n"
                        elif args.xygauss:
                            content_solvent += "  inside box "+str(round(X_min,2))+" "+str(round(Y_min,2))+" "+str(round(Z_dim[bilayer][0]+z_offset,2))+" "+str(round(X_max,2))+" "+str(round(Y_max,2))+" "+str(Z_dim[bilayer][1])+"\n"
                            content_solvent += "  over xygauss 0. 0. "+args.xygauss[0]+" "+args.xygauss[1]+" "+str(leaflet_z+z_offset)+" "+args.xygauss[2]+"\n"
                        else:
                            content_solvent += "  inside box "+str(round(X_min,2))+" "+str(round(Y_min,2))+" "+str(leaflet_z+z_offset)+" "+str(round(X_max,2))+" "+str(round(Y_max,2))+" "+str(round(Z_dim[bilayer][1]+z_offset,2))+"\n"
                        content_solvent += "end structure\n\n"
                elif solvents_down+solvents_up > 0:
                    content_solvent += "structure "+solvent_pdb+"\n"
                    content_solvent += "  nloop "+str(nloop)+"\n"
                    content_solvent += "  number "+str(solvents_down+solvents_up)+"\n" # deleted -pos-neg. Was it necessary?
                    content_solvent += "  inside box "+str(round(X_min,2))+" "+str(round(Y_min,2))+" "+str(round(Z_dim[bilayer][0]+z_offset,2))+" "+str(round(X_max,2))+" "+str(round(Y_max,2))+" "+str(round(Z_dim[bilayer][1]+z_offset,2))+"\n"
                    content_solvent += "end structure\n\n"

        if args.nocounter:
            logger.info("Ions will not be added. PMEMD will assume a counter charge 'plasma'.")
            content_ion = ""
        contents = content_header+content_prot+content_lipid+content_solvent+content_ion+content_solute

        with open(args.packlog+".inp","w+") as script:

    #        script = open(args.packlog+".inp","w+")
            script.write(contents)
    #        script = script.seek(0, os.SEEK_SET) # reset script file pointer for packmol
            script.seek(0, os.SEEK_SET)

            if not args.solvate:
                box_data = """
                Lower water box vol    = %-9s A^3
                Upper water box vol    = %-9s A^3
                Mem. upper leaflet vol = %-9s A^3
                Mem. lower leaflet vol = %-9s A^3

                """

                logger.debug(box_data % (round(solvent_vol_down,2), round(solvent_vol_up,2), round(lipid_vol_up,2), round(lipid_vol_down,2)))
            else:
                box_data = """
                Water box vol    = %-9s A^3

                """

                logger.debug(box_data % (round(solvent_vol_down+solvent_vol_up,2)))

            logger.debug("Script for packmol written to "+args.packlog+".inp")

            if packmol != None and os.path.exists(packmol) and run:
                logger.info("\nRunning Packmol...")
                log = open(args.packlog+".log","w")
                p = subprocess.Popen(packmol, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, stdin=script)#, env=my_env)
#                p = subprocess.Popen(packmol, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, stdin=content_header+content_prot+content_lipid+content_solvent+content_ion+content_solute)
                global pid
                pid = p.pid
                def kill_child():
                    if pid is None:
                        pass
                    else:
                        try:
                            os.kill(pid, signal.SIGTERM)
                        except:
                            pass
                atexit.register(kill_child)
                GENCAN_track = 0
                TOTGENCAN    = 0
                FRAME        = 0
                energy_values = []
                starting = True
                all_together = False
                progress_bar = True
                step = 1
                while True:
                    output = p.stdout.readline().decode('utf-8')
                    log.write(output)
                    if output == '' and p.poll() is not None:
                        break
                    if "Number of independent structures:" in output.strip():
                        structs = output.strip().split()[-1]
                        if not args.packall:
                            if not onlymembrane:
                                TOTAL = int(nloop)*(int(structs)-1)+nloop_all
                            else:
                                TOTAL = int(nloop)*(int(structs))+nloop_all
                        else:
                            TOTAL = int(nloop_all)
                        mag   = int(math.log10(TOTAL))+2
                        if not onlydots:
                            p_bar = tqdm.tqdm(total=TOTAL)

                    if "Starting GENCAN loop"  in output.strip():
                        if GENCAN_track < nloop+1:
                            GENCAN_track += 1; TOTGENCAN += 1
                        if onlydots:
                            if GENCAN_track % 10 == 0:
                                sys.stdout.write(".")
                                sys.stdout.flush()
                        if not onlydots and GENCAN_track <= nloop:
                            p_bar.update(1)
                    if "Packing molecules " in output.strip():
                        if onlydots:
#                            sys.stdout.write("\033[F")
                            sys.stdout.write("\r" +"\nProcessing segment "+output.strip().split()[-1]+" of "+structs)
                            sys.stdout.flush()
                        else:
                            if int(nloop)-GENCAN_track > 0 and not starting:
                                p_bar.update(int(nloop)-GENCAN_track)
                            else:
                                starting = False
                            p_bar.set_description("Molecule segment %s/%s" % (output.strip().split()[-1],structs))
                        GENCAN_track = 0
                    if ("Current solution written to file" in output.strip() or "Writing current (perhaps bad) structure to file" in output.strip()) and args.traj:
                        FRAME += 1
                        shutil.move(outfile,outfile.replace(".pdb","_"+("{:0"+str(mag)+"d}").format(FRAME)+".pdb"))
                    if "Packing all molecules together" in output.strip():
                        all_together = True
                        if not onlydots:
                            if int(nloop)-GENCAN_track > 0 and not args.packall:
                                p_bar.update(int(nloop)-GENCAN_track)
                            p_bar.set_description("All-together Packing")
                        logger.debug("\nIndividual packing processes complete. Initiating all-together packing. This might take a while!")
                        sys.stdout.write("\033[F")
                        sys.stdout.write("\r" +"\nAll-together Packing")
                        sys.stdout.flush()
                        GENCAN_track = 0
                        nloop = nloop_all
                    if "All-type function" in output.strip():
                        fnx_value = float(output.strip().split()[-1])
                        energy_values.append((TOTGENCAN,fnx_value))
                    if "Function value from last GENCAN" in output.strip() and all_together:
                        fnx_value = float(output.strip().split()[-1])
                        energy_values.append((TOTGENCAN,fnx_value))
                    if "Success!" in output.strip():
                        p_bar.update(int(nloop)-GENCAN_track)

#            script.close()

        if run and args.plot:
            try:
                import matplotlib
                matplotlib.use('Agg')
                import matplotlib.pyplot as plt
                matplotlib.rcParams["font.sans-serif"]='Arial'
                plt.plot(*list(zip(*energy_values)),color="black")
                plt.xlabel('Iteration')
                plt.ylabel('Objective function')
                plt.savefig(outfile+'.png')
            except:
                logger.error("ERROR:\n    Matplotlib could not be imported. Check that you have a working version.")
            with open("GENCAN.log","w") as gencanlog:
                gencanlog.write("\n".join("%s %s" % x for x in energy_values))

        elif not os.path.exists(packmol) or not run:
            logger.info("The script generated can be run by using a packmol executable ($PACKMOL_PATH < memgen.inp)")
            exit()

        if not os.path.exists(outfile):
            logger.critical("CRITICAL:\n  No output file generated by PACKMOL. Check packmol.log and if the initial set of constraints are adequate for your system (e.g. leaflet size, tail and head planes)!")
            exit()


    if not args.charmm:
        logger.info("Transforming to AMBER")
        charmmlipid2amber(outfile,outfile, os.path.join(script_path, lib, "charmmlipid2amber", "charmmlipid2amber.csv"))

        if sterols_used:
            logger.info("Sterols were packed. Potential piercing lipid tails will be searched")
            try:
                to_remove = find_piercing_lipids(outfile, verbose=True)
                try:                
                    if len(to_remove) > 0:
                       outfile = remove_piercing_lipids(outfile, to_remove, outfile=outfile.replace(".pdb","_noclash.pdb"), verbose=True)
                except:
                    logger.warning("Lipid piercing removal failed. Check your structure manually in case of clashing lipid tails!")
            except:
                logger.warning("Lipid piercing finder failed. Check your structure manually in case of clashing lipid tails!")

        if args.parametrize:
            logger.info("Parametrizing using LEaP with %s, %s and %s" % (args.fflip, args.ffprot, args.ffwat))
            infiles = prepare_leap(
                        outfile,
                        ligands=args.ligand_param,
                        cation=ion_dict[args.salt_c][2],
                        anion=ion_dict[args.salt_a][2],
                        sirah=args.sirah,
                        suffix="_wat" if args.solvate else "_lipid",
                        custom_lines=args.leapline,
                        gaff2=args.gaff2, 
                        nocounter=args.nocounter, 
                        ffprot=args.ffprot, 
                        ffwat=args.ffwat,
                        fflip=args.fflip, 
                        extended=extended,
                        x_solvent=(args.solvents != "WAT"),
                        dim_vec=[X_len,Y_len,sum([zdim[2] for zdim in Z_dim])] if args.tight_box else None, 
                        cli=any(["CL" in lipid for lipid in lipids]))

            if os.stat(infiles[1]).st_size == 0:
                args.minimize = False
                logger.error("ERROR:\n    Parametrization Failed! Check that all the components parameters are included (leap_.log file for details)")
                exit()
            created.extend(("leap.log","leap_ .log","leap.in"))
        if args.minimize:
            logger.info("Minimizing...")
            if args.pdb is not None:
                prot_residues = sum([len(pdb_parse(pdb)) for pdb in args.pdb])
            if args.sander:
                engine = "sander"
            else:
                engine = "pmemd"
            if args.pdb is not None:
                minimized_restraint = amber_minimize(infiles,"(:1-"+str(prot_residues)+" | @P31)", sd_steps = 250, cg_steps = 250,engine=engine)
            else:
                minimized_restraint = amber_minimize(infiles,sd_steps = 250, cg_steps = 250,engine=engine)
            if os.stat(minimized_restraint[0]).st_size == 0:
                args.minimize = False
                logger.error("ERROR:\n    Restrained minimization Failed! (log files for details)")
                exit()
            minimized = amber_minimize(minimized_restraint, sd_steps = 250, cg_steps = 250,min_script=outfile.replace(".pdb","_min.in"),engine=engine,outfile=outfile.replace(".pdb","_min.pdb"))
            if os.stat(minimized[0]).st_size == 0:
                args.minimize = False
                logger.error("ERROR:\n    Minimization Failed! (log files for details)")
                exit()

    if delete:
        logger.debug("Deleting temporary files...")
        for file in created:
            try:
                os.remove(file)
            except:
                pass
        if run:
            for file in created_notrun:
                try:
                    os.remove(file)
                except:
                    pass

    warn = "#Packing process finished. Check your final structure, particularly for lipids inserted in proteins, protein tunnels or piercing rings!#"
    print("\n"+"#"*len(warn))
    logger.info(warn)
    print("#"*len(warn))
    print("DONE!")

if __name__ == "__main__":
    logger.setLevel(logging.DEBUG)

    streamer = logging.StreamHandler()
    streamer.setLevel(logging.INFO)
    logger.addHandler(streamer)

    logger.info(head)

    args = parser.parse_args()
    main(args)
